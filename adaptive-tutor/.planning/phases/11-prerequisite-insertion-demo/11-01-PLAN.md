---
phase: 11-prerequisite-insertion-demo
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/demo-seeds.ts
  - src/lib/prompts/index.ts
  - src/app/api/study-plans/[id]/analyze-gap/route.ts
  - src/app/api/study-plans/[id]/suggest-extension/route.ts
  - src/app/api/study-plans/[id]/concepts/insert/route.ts
autonomous: true

must_haves:
  truths:
    - "Seeded mode returns pre-computed gap/extension proposals without calling LLM"
    - "analyze-gap route accepts conceptId + answer context and returns a gap proposal"
    - "suggest-extension route accepts conceptId and returns an extension proposal"
    - "concepts/insert route supports position=extension with correct edge direction (anchor->new)"
    - "Both analyze-gap and suggest-extension routes return valid JSON responses for both seeded and live (non-seeded) requests"
  artifacts:
    - path: "src/lib/demo-seeds.ts"
      provides: "Seed configuration with findDemoSeed() function"
      exports: ["findDemoSeed", "DEMO_SEEDS"]
    - path: "src/app/api/study-plans/[id]/analyze-gap/route.ts"
      provides: "POST endpoint for on-demand gap analysis"
      exports: ["POST"]
    - path: "src/app/api/study-plans/[id]/suggest-extension/route.ts"
      provides: "POST endpoint for on-demand extension suggestion"
      exports: ["POST"]
    - path: "src/app/api/study-plans/[id]/concepts/insert/route.ts"
      provides: "Modified insert endpoint with position field"
      contains: "position.*extension"
  key_links:
    - from: "src/lib/demo-seeds.ts"
      to: "analyze-gap/route.ts"
      via: "seeded body field bypass"
      pattern: "body\\.seeded"
    - from: "src/lib/demo-seeds.ts"
      to: "suggest-extension/route.ts"
      via: "seeded body field bypass"
      pattern: "body\\.seeded"
    - from: "concepts/insert/route.ts"
      to: "prisma.conceptEdge.create"
      via: "conditional edge direction based on position"
      pattern: "position.*extension"
---

<objective>
Create the seed configuration, two new API routes (analyze-gap and suggest-extension), and modify the existing concepts/insert route to support extension edge direction.

Purpose: These are the backend building blocks for the demo. The seed config enables guaranteed demos without LLM dependency. The two API routes provide on-demand analysis (complementing the existing automatic 2-occurrence gap detection). The insert modification enables upward graph growth (extensions), not just downward (prerequisites).

Output: 4 new/modified files enabling the full backend flow for both gap and extension insertion.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@src/app/api/study-plans/[id]/concepts/insert/route.ts
@src/app/api/study-plans/[id]/concepts/add-custom/route.ts
@src/lib/minimax-native.ts
@src/lib/schemas.ts
@src/lib/prompts/index.ts
@src/components/GapProposalCard.tsx
@prisma/seed-test-accounts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create demo-seeds.ts and two API routes (analyze-gap + suggest-extension)</name>
  <files>
    src/lib/demo-seeds.ts
    src/lib/prompts/index.ts
    src/app/api/study-plans/[id]/analyze-gap/route.ts
    src/app/api/study-plans/[id]/suggest-extension/route.ts
  </files>
  <action>
**1a. Create `src/lib/demo-seeds.ts`** (~60 lines)

Define a seed configuration object and lookup function. The seeds map concept name patterns (case-insensitive regex) to pre-computed gap and extension proposals.

```typescript
export interface DemoSeed {
  type: "gap" | "extension";
  conceptPattern: RegExp;      // Matches concept name
  missingConcept?: string;     // For gap seeds
  suggestedConcept?: string;   // For extension seeds
  explanation: string;
  severity?: string;
}

export const DEMO_SEEDS: DemoSeed[] = [
  // Gap seeds (prerequisite detection)
  {
    type: "gap",
    conceptPattern: /deriv/i,
    missingConcept: "Limit Definition",
    explanation: "Derivatives are defined as limits. Understanding limits is essential before working with derivatives.",
    severity: "high",
  },
  {
    type: "gap",
    conceptPattern: /calculus/i,
    missingConcept: "Algebra Fundamentals",
    explanation: "Calculus builds on algebraic manipulation. You need solid algebra skills first.",
    severity: "high",
  },
  {
    type: "gap",
    conceptPattern: /hash.?table/i,
    missingConcept: "Array Fundamentals",
    explanation: "Hash tables use arrays internally. Understanding arrays is a prerequisite.",
    severity: "high",
  },
  {
    type: "gap",
    conceptPattern: /backprop/i,
    missingConcept: "Chain Rule",
    explanation: "Backpropagation is an application of the chain rule from calculus.",
    severity: "high",
  },
  // Extension seeds (what to learn next)
  {
    type: "extension",
    conceptPattern: /deriv/i,
    suggestedConcept: "Integration Techniques",
    explanation: "You have a strong grasp of derivatives. Integration is the natural next step in calculus.",
  },
  {
    type: "extension",
    conceptPattern: /calculus/i,
    suggestedConcept: "Multivariable Calculus",
    explanation: "Extend your calculus knowledge to functions of multiple variables.",
  },
  {
    type: "extension",
    conceptPattern: /array/i,
    suggestedConcept: "Dynamic Arrays & Amortized Analysis",
    explanation: "Dive deeper into how arrays resize and the amortized cost analysis.",
  },
  {
    type: "extension",
    conceptPattern: /hash.?table/i,
    suggestedConcept: "Balanced Binary Search Trees",
    explanation: "Another key data structure for efficient lookup and ordered operations.",
  },
];

export function findDemoSeed(conceptName: string, type: "gap" | "extension"): DemoSeed | null {
  return DEMO_SEEDS.find(s => s.type === type && s.conceptPattern.test(conceptName)) ?? null;
}
```

**1b. Add two prompt functions to `src/lib/prompts/index.ts`**

Append two new exported functions at the end of the file:

`gapAnalysisPrompt(conceptName, questionText, userAnswer, correctAnswer)` - System prompt for on-demand gap analysis. Instructs LLM to analyze a wrong answer and identify if there is a missing prerequisite concept. Output JSON: `{ hasGap: boolean, missingConcept: string | null, explanation: string, severity: "high" | "medium" | "low" }`. Follow the conservative classification pattern from `evaluateFreeResponsePrompt` (most errors are NOT prerequisite gaps).

`extensionSuggestionPrompt(conceptName, existingConcepts)` - System prompt for extension suggestion. Instructs LLM to suggest a logical next topic to learn after mastering the given concept. Takes array of existing concept names to avoid duplicates. Output JSON: `{ suggestedConcept: string, explanation: string, direction: "deeper" | "broader" | "applied" }`.

Both prompts must end with "Return ONLY valid JSON, no markdown fences." to match the existing `advisorPrompt` pattern.

**1c. Create `src/app/api/study-plans/[id]/analyze-gap/route.ts`** (~80 lines)

POST route. Follow the exact pattern from `add-custom/route.ts` (await params, x-user-id header, study plan ownership check).

Request body: `{ conceptId, conceptName, questionText, userAnswer, correctAnswer, seeded? }`.

Seeded bypass: If `body.seeded` is truthy, return the seeded data directly as the response without calling LLM. The seeded object should contain `{ missingConcept, explanation, severity }`. Return: `{ hasGap: true, missingConcept: body.seeded.missingConcept, explanation: body.seeded.explanation, severity: body.seeded.severity || "high", parentConceptId: body.conceptId }`.

Live LLM mode: Call `generateText()` with `gapAnalysisPrompt(...)`, parse with `parseLLMJson()`, validate shape, return the result. Use `{ temperature: 0.2, maxTokens: 512 }` for deterministic output. If LLM fails or returns `hasGap: false`, return `{ hasGap: false }`.

Import `generateText` from `@/lib/minimax-native`, `parseLLMJson` from `@/lib/schemas`, `gapAnalysisPrompt` from `@/lib/prompts`.

**1d. Create `src/app/api/study-plans/[id]/suggest-extension/route.ts`** (~80 lines)

POST route. Same auth/ownership pattern as analyze-gap.

Request body: `{ conceptId, conceptName, existingConcepts: string[], seeded? }`.

Seeded bypass: If `body.seeded` is truthy, return: `{ hasSuggestion: true, suggestedConcept: body.seeded.suggestedConcept, explanation: body.seeded.explanation, anchorConceptId: body.conceptId }`.

Live LLM mode: Call `generateText()` with `extensionSuggestionPrompt(...)`, parse with `parseLLMJson()`, return result. Use `{ temperature: 0.4, maxTokens: 512 }` for slightly more creative suggestions.

Error fallback for both routes: If LLM call throws, return a 200 with `{ hasGap: false }` or `{ hasSuggestion: false }` respectively (never 500 on LLM failure -- matches the existing pattern from explain route returning fallback on failure).
  </action>
  <verify>
1. `npx tsc --noEmit` passes with zero errors
2. `curl -X POST http://localhost:3000/api/study-plans/gap-study-plan-1/analyze-gap -H "Content-Type: application/json" -H "x-user-id: gap-test-user" -d '{"conceptId":"calculus-concept-1","conceptName":"Differential Calculus","questionText":"test","userAnswer":"test","correctAnswer":"test","seeded":{"missingConcept":"Limit Definition","explanation":"Test explanation","severity":"high"}}'` returns `{"hasGap":true,"missingConcept":"Limit Definition",...}`
3. `curl -X POST http://localhost:3000/api/study-plans/gap-study-plan-1/suggest-extension -H "Content-Type: application/json" -H "x-user-id: gap-test-user" -d '{"conceptId":"calculus-concept-1","conceptName":"Differential Calculus","existingConcepts":["Algebra"],"seeded":{"suggestedConcept":"Integration Techniques","explanation":"Test"}}'` returns `{"hasSuggestion":true,"suggestedConcept":"Integration Techniques",...}`
4. Live LLM fallback check: `curl -X POST http://localhost:3000/api/study-plans/gap-study-plan-1/analyze-gap -H "Content-Type: application/json" -H "x-user-id: gap-test-user" -d '{"conceptId":"calculus-concept-1","conceptName":"Differential Calculus","questionText":"test","userAnswer":"test","correctAnswer":"test"}'` returns a valid JSON response (200 status, not 500) -- either `{"hasGap":true,...}` or `{"hasGap":false}` depending on LLM availability
  </verify>
  <done>
- demo-seeds.ts exports findDemoSeed() and DEMO_SEEDS with at least 4 gap seeds and 4 extension seeds
- analyze-gap route returns pre-computed response when seeded field is present
- suggest-extension route returns pre-computed response when seeded field is present
- Both routes fall back to LLM when seeded is absent
- Both routes return graceful fallback (not 500) on LLM failure
- Live (non-seeded) requests return valid JSON 200 responses regardless of LLM availability
- TypeScript compiles with zero errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Modify concepts/insert route for extension edge direction</name>
  <files>
    src/app/api/study-plans/[id]/concepts/insert/route.ts
  </files>
  <action>
Modify the existing `concepts/insert/route.ts` to accept an optional `position` field in the request body.

**Changes:**

1. Update destructuring to include `position`: `const { unitGraphId, conceptName, targetConceptId, position } = body;`. The `position` field is optional with default `"prerequisite"`.

2. Replace the hardcoded edge direction logic. Currently the code always does:
   - `fromNodeId: prerequisiteConceptId` (new concept)
   - `toNodeId: targetConceptId` (anchor concept)
   - `newDepthTier = Math.max(1, targetMembership.depthTier - 1)`

   Replace with conditional:
   ```
   if position === "extension":
     fromNodeId = targetConceptId (anchor)
     toNodeId = newConceptId (new concept)
     newDepthTier = targetMembership.depthTier + 1
   else (default "prerequisite"):
     fromNodeId = newConceptId (new concept is prereq)
     toNodeId = targetConceptId (anchor)
     newDepthTier = Math.max(1, targetMembership.depthTier - 1)
   ```

3. Update the edge lookup and creation to use the computed fromNodeId/toNodeId (currently hardcoded to `prerequisiteConceptId` and `targetConceptId`).

4. Update the variable name from `prerequisiteConceptId` to `newConceptId` (or alias it) since for extensions, the new concept is NOT a prerequisite. The `findOrCreateConcept` call stays the same -- just the variable name and edge direction change.

5. Update the response to include `position` and the correct edge direction:
   ```
   return NextResponse.json({
     conceptId: newConceptId,
     membership: newMembership,
     edge: { from: fromNodeId, to: toNodeId },
     layout,
     position: position || "prerequisite",
   });
   ```

6. Update the JSDoc comment at the top to document the new `position` field.

**Do NOT change:** The ownership check, force layout computation, position persistence, or fire-and-forget question generation. These all stay the same.

**Risk mitigation:** The `getLockedConcepts()` function checks prerequisite edges (fromNodeId -> toNodeId means fromNodeId is prereq OF toNodeId). For extensions, the anchor is fromNodeId and the new concept is toNodeId -- this means the new extension concept will correctly NOT be locked (it has no prerequisites that are unmastered). The anchor concept is NOT affected by the new edge (it was already mastered). So prerequisite locking logic remains correct without changes.
  </action>
  <verify>
1. `npx tsc --noEmit` passes with zero errors
2. Test prerequisite insertion still works: `curl -X POST http://localhost:3000/api/study-plans/gap-study-plan-1/concepts/insert -H "Content-Type: application/json" -H "x-user-id: gap-test-user" -d '{"unitGraphId":"gap-graph-1","conceptName":"Test Prereq","targetConceptId":"calculus-concept-1"}'` returns edge with from=newConcept, to=calculus
3. Test extension insertion: `curl -X POST http://localhost:3000/api/study-plans/gap-study-plan-1/concepts/insert -H "Content-Type: application/json" -H "x-user-id: gap-test-user" -d '{"unitGraphId":"gap-graph-1","conceptName":"Test Extension","targetConceptId":"calculus-concept-1","position":"extension"}'` returns edge with from=calculus, to=newConcept
4. Verify the depthTier: extension concept should have depthTier = target's tier + 1
  </verify>
  <done>
- concepts/insert accepts optional position field ("prerequisite" | "extension")
- Default behavior (no position or position="prerequisite") is unchanged from current behavior
- position="extension" reverses edge direction: anchor -> new concept (not new -> anchor)
- Extension concepts placed at depthTier + 1 (below anchor in graph)
- Response includes position field
- Prerequisite locking logic unaffected
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero TypeScript errors across all new/modified files
2. `npm run build` -- successful Next.js build (validates route exports and imports)
3. Seeded bypass works for both analyze-gap and suggest-extension (curl tests with seeded field)
4. Live (non-seeded) requests return valid JSON 200 responses (not 500) for both routes
5. concepts/insert backwards-compatible (existing callers without position field still work as prerequisite insertion)
6. Extension edge direction is correct (anchor -> new, not new -> anchor)
</verification>

<success_criteria>
- 3 new files created (demo-seeds.ts, analyze-gap/route.ts, suggest-extension/route.ts)
- 2 files modified (concepts/insert/route.ts, prompts/index.ts)
- Seeded mode bypasses LLM and returns pre-computed responses
- Live LLM mode works when seeded is absent (with graceful fallback on failure)
- Both routes return valid 200 JSON for non-seeded requests regardless of LLM availability
- Extension insertion produces correct edge direction and tier placement
- Zero TypeScript errors, successful build
</success_criteria>

<output>
After completion, create `.planning/phases/11-prerequisite-insertion-demo/11-01-SUMMARY.md`
</output>
