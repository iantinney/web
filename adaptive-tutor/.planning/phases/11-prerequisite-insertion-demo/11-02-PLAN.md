---
phase: 11-prerequisite-insertion-demo
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/components/ExtensionProposalCard.tsx
  - src/app/(tabs)/learn/page.tsx
autonomous: true

must_haves:
  truths:
    - "User sees 'Analyze Gap' button in feedback phase after a wrong answer"
    - "User sees 'Explore Next' button in feedback phase after a correct answer"
    - "Clicking 'Analyze Gap' calls analyze-gap API and shows GapProposalCard with result"
    - "Clicking 'Explore Next' calls suggest-extension API and shows ExtensionProposalCard with result"
    - "Confirming gap proposal inserts prerequisite concept and redirects practice to it"
    - "Confirming extension proposal inserts extension concept and starts practice on it"
    - "Keyboard shortcuts Ctrl+G and Ctrl+E trigger the same flows"
    - "Graph data reloads after any insertion so new node appears in graph tab"
  artifacts:
    - path: "src/components/ExtensionProposalCard.tsx"
      provides: "Blue/teal themed proposal card for extension suggestions"
      exports: ["ExtensionProposalCard"]
      min_lines: 60
    - path: "src/app/(tabs)/learn/page.tsx"
      provides: "Keyboard shortcuts, trigger buttons, analysis state, shared insertion handler"
      contains: "triggerGapAnalysis"
  key_links:
    - from: "src/app/(tabs)/learn/page.tsx"
      to: "/api/study-plans/[id]/analyze-gap"
      via: "fetch in triggerGapAnalysis"
      pattern: "fetch.*analyze-gap"
    - from: "src/app/(tabs)/learn/page.tsx"
      to: "/api/study-plans/[id]/suggest-extension"
      via: "fetch in triggerExtensionAnalysis"
      pattern: "fetch.*suggest-extension"
    - from: "src/app/(tabs)/learn/page.tsx"
      to: "/api/study-plans/[id]/concepts/insert"
      via: "fetch in handleInsertConcept"
      pattern: "concepts/insert.*position"
    - from: "src/app/(tabs)/learn/page.tsx"
      to: "src/lib/demo-seeds.ts"
      via: "import findDemoSeed for seeded mode detection"
      pattern: "findDemoSeed"
---

<objective>
Wire up the Learn page with keyboard shortcuts, trigger buttons, the ExtensionProposalCard component, and a shared insertion handler that works for both gap (prerequisite) and extension (upward) insertion flows.

Purpose: This is the user-facing layer of the demo. After Plan 01 builds the backend, this plan connects the UI so users can trigger on-demand gap/extension analysis during the feedback phase, see proposal cards, and confirm insertions that grow the knowledge graph in both directions.

Output: 1 new component (ExtensionProposalCard) and significant modifications to learn/page.tsx with keyboard shortcuts, analysis triggers, and shared insertion logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/11-prerequisite-insertion-demo/11-01-SUMMARY.md
@src/app/(tabs)/learn/page.tsx
@src/components/GapProposalCard.tsx
@src/lib/demo-seeds.ts
@src/lib/store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ExtensionProposalCard component</name>
  <files>
    src/components/ExtensionProposalCard.tsx
  </files>
  <action>
Create `src/components/ExtensionProposalCard.tsx` modeled on the existing `GapProposalCard.tsx` (116 lines). This is a blue/teal themed counterpart for extension suggestions (vs amber for gaps).

**Props interface:**
```typescript
interface ExtensionProposalCardProps {
  currentConceptName: string;    // The concept user just answered correctly
  suggestedConceptName: string;  // The suggested extension topic
  explanation: string;           // Why this extension makes sense
  onConfirm: () => void;
  onDecline: () => void;
  isLoading?: boolean;
}
```

**Styling differences from GapProposalCard:**
- Background: `rgba(56, 189, 248, 0.08)` (blue tint, vs amber `rgba(255, 197, 61, 0.08)`)
- Border: `rgba(56, 189, 248, 0.4)` (blue border, vs amber)
- Header emoji: Use a rocket or arrow-up emoji (not the lightbulb used for gaps)
- Header text: "Ready for more?" (vs "I think something's missing")
- Sub-header: `You're doing great with <strong>{currentConceptName}</strong>!`
- Suggestion box: same structure as GapProposalCard, but text says "Next topic to explore:" instead of "You might be missing:"
- Confirm button text: "Explore this topic" (vs "Add to learning path")
- Confirm button uses blue accent: `backgroundColor: "rgb(56, 189, 248)"` (vs `var(--accent)`)
- Decline button: "Not now" (same as GapProposalCard)
- Footer: `Once added, you can start practicing <strong>{suggestedConceptName}</strong> right away.`

**Important:** Use the same CSS variable patterns as GapProposalCard (`var(--text-primary)`, `var(--bg-secondary)`, `var(--border)`, etc.) for all non-accent colors. Only the accent/highlight colors differ (blue vs amber).

Export as named export: `export const ExtensionProposalCard`.
Add `"use client"` directive at top.
Import `Loader2` from `lucide-react` for the loading spinner (same as GapProposalCard).
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. File exists at `src/components/ExtensionProposalCard.tsx`
3. Component exports `ExtensionProposalCard` with the correct props interface
4. Visual inspection: blue/teal color scheme (not amber)
  </verify>
  <done>
- ExtensionProposalCard component created with blue/teal theme
- Matches GapProposalCard structure but with extension-appropriate copy and colors
- Exports named component with correct prop types
- Uses existing CSS variable patterns for dark/light mode compatibility
  </done>
</task>

<task type="auto">
  <name>Task 2: Add keyboard shortcuts, trigger buttons, and shared insertion handler to learn/page.tsx</name>
  <files>
    src/app/(tabs)/learn/page.tsx
  </files>
  <action>
Modify `src/app/(tabs)/learn/page.tsx` to add on-demand gap/extension analysis with keyboard shortcuts, clickable buttons, and a unified insertion handler.

**IMPORTANT: Location Map for Task 2 Parts**

This file is ~1685 lines. Use this map to locate where each part's changes go. Read the file first and verify these landmarks before making changes (line numbers are approximate and may shift slightly after earlier parts are applied).

| Part | What | Where in file (approx line) |
|------|------|-----------------------------|
| A | New imports | ~line 1-15 (top of file, import block) |
| B | New state variables | ~line 120 (after `gapRedirectMessage` state) |
| C | `triggerGapAnalysis` function | ~line 681 (after `handleGapDecline`) |
| D | `triggerExtensionAnalysis` function | Immediately after Part C |
| E | `handleInsertConcept` shared handler + refactored `handleGapConfirm` + new `handleExtensionConfirm/Decline` | After Part D, replaces lines 620-674 |
| F | Keyboard shortcut `useEffect` | After Part E confirm/decline handlers |
| G | Trigger buttons in feedback JSX | ~line 1669 (inside `{isFeedback && lastResult && (...)}` guard, before "Next question" button) |
| H | `ExtensionProposalCard` render | ~line 1297 (after GapProposalCard block, OUTSIDE the feedback guard) |
| I | Reset analysis state in `handleAdvance` | ~line 491 (inside `handleAdvance` function body) |

**Part A: New imports (top of file)**

Add these imports:
```typescript
import { ExtensionProposalCard } from "@/components/ExtensionProposalCard";
import { findDemoSeed } from "@/lib/demo-seeds";
```
Add `ArrowDown, ArrowUp, Zap` to the lucide-react import (for button icons).

**Part B: New state variables (after existing gap detection state, around line 120)**

Add after the existing `gapRedirectMessage` state:
```typescript
// On-demand analysis state (keyboard shortcuts / buttons)
const [isAnalyzingGap, setIsAnalyzingGap] = useState(false);
const [isAnalyzingExtension, setIsAnalyzingExtension] = useState(false);

interface ExtensionProposal {
  conceptName: string;           // Current concept (anchor)
  suggestedConceptName: string;  // Extension to add
  explanation: string;
  anchorConceptId: string;       // ID of the current concept
}
const [extensionProposal, setExtensionProposal] = useState<ExtensionProposal | null>(null);
```

**Part C: triggerGapAnalysis function (after handleGapDecline, around line 681)**

```typescript
const triggerGapAnalysis = useCallback(async () => {
  if (!currentQuestion || !lastResult || !activeStudyPlanId || lastResult.isCorrect) return;
  setIsAnalyzingGap(true);

  try {
    const userId = getUserId();
    const conceptName = currentQuestion.conceptName ?? "Unknown";
    const seed = findDemoSeed(conceptName, "gap");

    const res = await fetch(`/api/study-plans/${activeStudyPlanId}/analyze-gap`, {
      method: "POST",
      headers: { "Content-Type": "application/json", "x-user-id": userId },
      body: JSON.stringify({
        conceptId: lastResult.proficiencyUpdate.conceptId,
        conceptName,
        questionText: currentQuestion.questionText,
        userAnswer: selectedMcqOption || textInput || "",
        correctAnswer: currentQuestion.correctAnswer ?? "",
        ...(seed ? { seeded: { missingConcept: seed.missingConcept, explanation: seed.explanation, severity: seed.severity } } : {}),
      }),
    });

    if (res.ok) {
      const data = await res.json();
      if (data.hasGap && data.missingConcept) {
        setShowGapProposal({
          conceptName,
          missingConceptName: data.missingConcept,
          explanation: data.explanation || "",
          targetConceptId: lastResult.proficiencyUpdate.conceptId,
        });
      }
    }
  } catch (err) {
    console.error("[triggerGapAnalysis] Error:", err);
  } finally {
    setIsAnalyzingGap(false);
  }
}, [currentQuestion, lastResult, activeStudyPlanId, selectedMcqOption, textInput]);
```

**Part D: triggerExtensionAnalysis function (immediately after triggerGapAnalysis)**

```typescript
const triggerExtensionAnalysis = useCallback(async () => {
  if (!currentQuestion || !lastResult || !activeStudyPlanId || !lastResult.isCorrect) return;
  setIsAnalyzingExtension(true);

  try {
    const userId = getUserId();
    const conceptName = currentQuestion.conceptName ?? "Unknown";
    const seed = findDemoSeed(conceptName, "extension");

    // Gather existing concept names to avoid duplicates
    const existingConcepts = graphConcepts.map(c => c.name);

    const res = await fetch(`/api/study-plans/${activeStudyPlanId}/suggest-extension`, {
      method: "POST",
      headers: { "Content-Type": "application/json", "x-user-id": userId },
      body: JSON.stringify({
        conceptId: lastResult.proficiencyUpdate.conceptId,
        conceptName,
        existingConcepts,
        ...(seed ? { seeded: { suggestedConcept: seed.suggestedConcept, explanation: seed.explanation } } : {}),
      }),
    });

    if (res.ok) {
      const data = await res.json();
      if (data.hasSuggestion && data.suggestedConcept) {
        setExtensionProposal({
          conceptName,
          suggestedConceptName: data.suggestedConcept,
          explanation: data.explanation || "",
          anchorConceptId: lastResult.proficiencyUpdate.conceptId,
        });
      }
    }
  } catch (err) {
    console.error("[triggerExtensionAnalysis] Error:", err);
  } finally {
    setIsAnalyzingExtension(false);
  }
}, [currentQuestion, lastResult, activeStudyPlanId, graphConcepts]);
```

**Part E: Shared handleInsertConcept function (after triggerExtensionAnalysis)**

This unifies insertion logic for both gap and extension flows. The existing `handleGapConfirm` should be replaced by this shared handler (or `handleGapConfirm` should call this).

```typescript
const handleInsertConcept = useCallback(async (
  type: "prerequisite" | "extension",
  conceptName: string,
  anchorConceptId: string,
) => {
  if (!activeStudyPlanId || !activeUnitGraphId) return;
  setIsInsertingConcept(true);

  try {
    const userId = getUserId();
    const insertRes = await fetch(
      `/api/study-plans/${activeStudyPlanId}/concepts/insert`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json", "x-user-id": userId },
        body: JSON.stringify({
          unitGraphId: activeUnitGraphId,
          conceptName,
          targetConceptId: anchorConceptId,
          position: type,
        }),
      }
    );

    if (insertRes.ok) {
      const insertData = await insertRes.json();
      const insertedConceptId: string = insertData.conceptId;

      // Reload graph data so the new concept appears
      loadUnitGraphData(activeUnitGraphId).catch(() => {});

      if (type === "prerequisite") {
        // Store redirect origin so mastery triggers redirect-back
        setRedirectedFromConceptId(anchorConceptId);
        setTargetConceptId(insertedConceptId);
        setGapRedirectMessage(
          `Added "${conceptName}" to your learning path. Let's master it first!`
        );
        setShowGapProposal(null);
      } else {
        // Extension: just start practicing the new concept (no redirect-back)
        setTargetConceptId(insertedConceptId);
        setGapRedirectMessage(
          `Added "${conceptName}" to your learning path. Let's explore it!`
        );
        setExtensionProposal(null);
      }

      // Reset session to start fresh on the new concept
      setQuestions([]);
      setQuestionIndex(0);
      setSessionId(null);
      setLastResult(null);
      setSessionStats({ attempted: 0, correct: 0 });
      setTimeout(() => {
        setGapRedirectMessage(null);
        initSession();
      }, 2000);
    } else {
      console.error("[handleInsertConcept] Insert failed:", await insertRes.text());
      setShowGapProposal(null);
      setExtensionProposal(null);
    }
  } catch (err) {
    console.error("[handleInsertConcept] Error:", err);
    setShowGapProposal(null);
    setExtensionProposal(null);
  } finally {
    setIsInsertingConcept(false);
  }
}, [activeStudyPlanId, activeUnitGraphId, loadUnitGraphData, setRedirectedFromConceptId, setTargetConceptId, initSession]);
```

**Replace the existing `handleGapConfirm`** (lines 620-674) with a wrapper that calls handleInsertConcept:
```typescript
const handleGapConfirm = useCallback(() => {
  if (!showGapProposal) return;
  handleInsertConcept("prerequisite", showGapProposal.missingConceptName, showGapProposal.targetConceptId);
}, [showGapProposal, handleInsertConcept]);
```

Add `handleExtensionConfirm`:
```typescript
const handleExtensionConfirm = useCallback(() => {
  if (!extensionProposal) return;
  handleInsertConcept("extension", extensionProposal.suggestedConceptName, extensionProposal.anchorConceptId);
}, [extensionProposal, handleInsertConcept]);

const handleExtensionDecline = useCallback(() => {
  setExtensionProposal(null);
}, []);
```

**Part F: Keyboard shortcut useEffect (after the confirm/decline handlers)**

```typescript
useEffect(() => {
  const handler = (e: KeyboardEvent) => {
    // Only active during feedback phase
    if (phase !== "feedback" || !lastResult) return;
    // Don't trigger if a proposal is already showing
    if (showGapProposal || extensionProposal) return;

    if (e.ctrlKey && e.key === "g" && !lastResult.isCorrect) {
      e.preventDefault();
      triggerGapAnalysis();
    }
    if (e.ctrlKey && e.key === "e" && lastResult.isCorrect) {
      e.preventDefault();
      triggerExtensionAnalysis();
    }
  };

  window.addEventListener("keydown", handler);
  return () => window.removeEventListener("keydown", handler);
}, [phase, lastResult, showGapProposal, extensionProposal, triggerGapAnalysis, triggerExtensionAnalysis]);
```

**Part G: UI - Render trigger buttons in feedback section**

**CRITICAL NESTING REQUIREMENT:** The trigger buttons access `lastResult.isCorrect`. They MUST be placed INSIDE the existing `{isFeedback && lastResult && (...)}` guard block that starts at ~line 1587 (the feedback section). Place them after the "Explain this" section (~line 1668) and BEFORE the "Next question" button (~line 1670). This ensures `lastResult` is guaranteed non-null.

The correct JSX nesting looks like this (showing surrounding context):

```jsx
        {/* Feedback section -- entire block is guarded by isFeedback && lastResult */}
        {isFeedback && lastResult && (
          <div className="flex flex-col gap-3">
            {/* ... Explanation block ... */}
            {/* ... Proficiency delta ... */}

            {/* Explain this -- only shown after wrong answers */}
            {!lastResult.isCorrect && (
              <div className="mt-1 flex flex-col gap-2">
                {/* ... existing explain button and text ... */}
              </div>
            )}

            {/* === NEW: Analysis trigger buttons === */}
            {!showGapProposal && !extensionProposal && (
              <div className="flex gap-2">
                {!lastResult.isCorrect && (
                  <button
                    onClick={triggerGapAnalysis}
                    disabled={isAnalyzingGap}
                    className="flex-1 flex items-center justify-center gap-1.5 py-2.5 rounded-xl text-xs font-medium border transition-opacity"
                    style={{
                      borderColor: "rgba(255, 197, 61, 0.4)",
                      backgroundColor: "rgba(255, 197, 61, 0.08)",
                      color: "var(--text-primary)",
                      opacity: isAnalyzingGap ? 0.6 : 1,
                    }}
                  >
                    {isAnalyzingGap ? <Loader2 size={12} className="animate-spin" /> : <ArrowDown size={12} />}
                    {isAnalyzingGap ? "Analyzing..." : "Analyze Gap"}
                    <span className="text-[10px] opacity-50 ml-1">Ctrl+G</span>
                  </button>
                )}
                {lastResult.isCorrect && (
                  <button
                    onClick={triggerExtensionAnalysis}
                    disabled={isAnalyzingExtension}
                    className="flex-1 flex items-center justify-center gap-1.5 py-2.5 rounded-xl text-xs font-medium border transition-opacity"
                    style={{
                      borderColor: "rgba(56, 189, 248, 0.4)",
                      backgroundColor: "rgba(56, 189, 248, 0.08)",
                      color: "var(--text-primary)",
                      opacity: isAnalyzingExtension ? 0.6 : 1,
                    }}
                  >
                    {isAnalyzingExtension ? <Loader2 size={12} className="animate-spin" /> : <ArrowUp size={12} />}
                    {isAnalyzingExtension ? "Analyzing..." : "Explore Next"}
                    <span className="text-[10px] opacity-50 ml-1">Ctrl+E</span>
                  </button>
                )}
              </div>
            )}
            {/* === END NEW === */}

            {/* Next question button */}
            <button onClick={handleAdvance} ...>
              Next Question <ChevronRight size={16} />
            </button>
          </div>
        )}
```

Do NOT place the trigger buttons outside the `{isFeedback && lastResult && (...)}` guard. The `lastResult.isCorrect` access would cause a null reference error during the "practicing" phase when `lastResult` is null.

**Part H: UI - Render ExtensionProposalCard**

**Design note:** The ExtensionProposalCard is intentionally placed OUTSIDE the `{isFeedback && lastResult && (...)}` feedback guard, at the same DOM level as the existing GapProposalCard (~line 1285-1296). Both proposal cards are rendered in the scroll area above the main question card, not inside the feedback section. This is the correct design: proposal cards are persistent UI elements that should remain visible regardless of feedback state transitions.

The `isInsertingConcept` state variable is the shared loading flag used by BOTH GapProposalCard and ExtensionProposalCard. It is set to `true` inside `handleInsertConcept` (Part E) and reset in the `finally` block. Both cards pass `isLoading={isInsertingConcept}`.

Right after the existing GapProposalCard render block (~line 1296), add:

```jsx
      {/* ---------------------------------------------------------------- */}
      {/* Extension proposal card                                           */}
      {/* ---------------------------------------------------------------- */}
      {extensionProposal && (
        <div className="px-4 mt-2">
          <ExtensionProposalCard
            currentConceptName={extensionProposal.conceptName}
            suggestedConceptName={extensionProposal.suggestedConceptName}
            explanation={extensionProposal.explanation}
            onConfirm={handleExtensionConfirm}
            onDecline={handleExtensionDecline}
            isLoading={isInsertingConcept}
          />
        </div>
      )}
```

**Part I: Reset analysis state on question advance**

In the `handleAdvance` function (~line 491), add cleanup at the top of the function body (after the existing `setExplainText(null)` and `setExplainLoading(false)` calls at ~line 494-495):
```typescript
setExtensionProposal(null);
setShowGapProposal(null);
setIsAnalyzingGap(false);
setIsAnalyzingExtension(false);
```

This ensures proposals don't persist across questions.

**IMPORTANT NOTES:**
- Do NOT remove the existing automatic gap detection flow (the fire-and-forget fetch to `gap-detections` in submitAttempt around line 435). The on-demand buttons are COMPLEMENTARY to the automatic 2-occurrence detection.
- The `findDemoSeed` is called CLIENT-SIDE. It checks if the current concept name matches a seed pattern and passes the seeded data to the API. The API then bypasses LLM and returns it directly. This means the seed lookup happens in the browser, not the server.
- The `graphConcepts` array is already available from the store destructuring at the top of the component. Use it for the existingConcepts parameter.
  </action>
  <verify>
1. `npx tsc --noEmit` passes with zero errors -- confirms no null-reference on `lastResult.isCorrect` (trigger buttons are inside the `isFeedback && lastResult` guard)
2. `npm run build` succeeds
3. Manual test flow (gap):
   a. Open Learn tab, practice any concept
   b. Answer incorrectly
   c. In feedback phase, see "Analyze Gap" button with Ctrl+G hint
   d. Click "Analyze Gap" or press Ctrl+G
   e. Loading spinner appears briefly
   f. GapProposalCard appears with prerequisite suggestion
   g. Click "Add to learning path"
   h. Session resets, targets new prerequisite concept
   i. Graph tab shows new node after refresh
4. Manual test flow (extension):
   a. Answer correctly
   b. See "Explore Next" button with Ctrl+E hint
   c. Click or press Ctrl+E
   d. ExtensionProposalCard appears with extension suggestion
   e. Click "Explore this topic"
   f. Session resets, targets new extension concept
5. Keyboard shortcuts work: Ctrl+G on wrong answer, Ctrl+E on correct answer
6. Proposals dismiss on "Not now" click
7. Proposals reset when advancing to next question
8. Verify both proposal cards render at the same DOM level outside the feedback-only JSX section (GapProposalCard at ~line 1285, ExtensionProposalCard immediately after)
  </verify>
  <done>
- ExtensionProposalCard component exists with blue/teal theme
- "Analyze Gap" button appears in feedback phase after wrong answers
- "Explore Next" button appears in feedback phase after correct answers
- Trigger buttons are INSIDE the `{isFeedback && lastResult && (...)}` guard -- no null-reference risk on `lastResult.isCorrect`
- Both proposal cards (GapProposalCard and ExtensionProposalCard) rendered at same DOM level outside feedback-only JSX section
- `isInsertingConcept` is the shared loading flag for both proposal cards
- Ctrl+G keyboard shortcut triggers gap analysis
- Ctrl+E keyboard shortcut triggers extension analysis
- Seeded mode is used automatically when concept name matches demo seeds
- Gap confirmation inserts prerequisite (position=prerequisite), sets redirect-back
- Extension confirmation inserts extension (position=extension), starts practice
- Graph reloads after any insertion
- Existing automatic gap detection flow is preserved (not removed)
- If newly inserted concept has no questions after session reset, the "No questions available" state is shown (question generation runs as fire-and-forget on insert; if not yet ready, user can re-enter Learn tab to retry)
- Zero TypeScript errors, successful build
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero TypeScript errors
2. `npm run build` -- successful Next.js build
3. Full demo flow works end-to-end with seeded data:
   - Practice a concept matching seed pattern (e.g., "Derivatives" or "Differential Calculus")
   - Wrong answer -> Ctrl+G -> GapProposalCard -> confirm -> prerequisite inserted -> practice redirected
   - Master prerequisite -> auto-redirect back to original
   - Correct answer -> Ctrl+E -> ExtensionProposalCard -> confirm -> extension inserted -> practice starts
4. Graph tab shows new nodes after insertion (both prerequisite and extension)
5. Keyboard shortcuts only fire during feedback phase (not during answering or idle)
6. Buttons show loading state during API calls
7. Proposals can be declined without side effects
8. Both proposal cards are at the same DOM level (outside feedback guard), trigger buttons are inside feedback guard
</verification>

<success_criteria>
- 1 new file created (ExtensionProposalCard.tsx)
- 1 file significantly modified (learn/page.tsx)
- Both gap and extension insertion flows work end-to-end
- Keyboard shortcuts (Ctrl+G, Ctrl+E) functional
- Clickable buttons as primary UX, shortcuts as secondary
- Seeded mode delivers guaranteed demo experience
- Graph grows in both directions (downward prerequisites, upward extensions)
- Zero TypeScript errors, successful build
</success_criteria>

<output>
After completion, create `.planning/phases/11-prerequisite-insertion-demo/11-02-SUMMARY.md`
</output>
