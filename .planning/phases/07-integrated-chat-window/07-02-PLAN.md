---
phase: 07-integrated-chat-window
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - adaptive-tutor/src/app/api/explain/route.ts
  - adaptive-tutor/src/app/api/chat/route.ts
  - adaptive-tutor/src/app/(tabs)/learn/page.tsx
autonomous: true
requirements:
  - CHAT-CONTEXT-03
  - CHAT-CONTEXT-04

must_haves:
  truths:
    - "After a wrong answer in Learn tab, user sees an 'Explain this' button below the feedback card"
    - "Clicking 'Explain this' calls the LLM and renders a 2-4 sentence explanation below the feedback card"
    - "The 'Explain this' button is NOT shown after correct answers"
    - "The explanation block clears when the user advances to the next question"
    - "Chat API system prompt includes a chatContext snippet when chatContext is provided"
    - "Submitting an attempt updates chatContext.recentAttempts and chatContext.activeConceptId in the store"
  artifacts:
    - path: "adaptive-tutor/src/app/api/explain/route.ts"
      provides: "POST endpoint accepting question/userAnswer/correctAnswer/feedback/conceptName/chatContext, returns { explanation: string }"
      exports: ["POST"]
    - path: "adaptive-tutor/src/app/api/chat/route.ts"
      provides: "Modified chatSystemPrompt call to include chatContextSnippet from request body"
      contains: "buildChatContextSnippet"
    - path: "adaptive-tutor/src/app/(tabs)/learn/page.tsx"
      provides: "Explain this button in feedback phase (wrong answers only), explanation block with loading state, recordAttemptInContext and setChatContext calls after submitAttempt"
      contains: "handleExplainThis"
  key_links:
    - from: "adaptive-tutor/src/app/(tabs)/learn/page.tsx"
      to: "adaptive-tutor/src/app/api/explain/route.ts"
      via: "fetch POST /api/explain with question/answer/concept data"
      pattern: "fetch.*api/explain"
    - from: "adaptive-tutor/src/app/api/explain/route.ts"
      to: "adaptive-tutor/src/lib/prompts/index.ts"
      via: "explainAnswerPrompt() called to build system prompt"
      pattern: "explainAnswerPrompt"
    - from: "adaptive-tutor/src/app/api/chat/route.ts"
      to: "adaptive-tutor/src/lib/prompts/index.ts"
      via: "buildChatContextSnippet() called when chatContext in request body"
      pattern: "buildChatContextSnippet"
---

<objective>
Build the inline "Explain this" explainer feature in the Learn tab and extend the Chat API to inject chatContext into its system prompt.

Purpose: After a wrong answer, users can request a targeted Socratic explanation without leaving the practice flow. Simultaneously, the chat tutor becomes context-aware — it knows what the user was just practicing.
Output: New /api/explain route, modified /api/chat route (chatContext injection), modified learn/page.tsx (Explain button + key-event store updates).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-integrated-chat-window/07-CONTEXT.md
@.planning/phases/07-integrated-chat-window/07-RESEARCH.md
@.planning/phases/07-integrated-chat-window/07-01-SUMMARY.md
@adaptive-tutor/src/app/api/explain/route.ts
@adaptive-tutor/src/app/api/chat/route.ts
@adaptive-tutor/src/app/(tabs)/learn/page.tsx
@adaptive-tutor/src/lib/minimax-native.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /api/explain route</name>
  <files>adaptive-tutor/src/app/api/explain/route.ts</files>
  <action>
Create a new file at `adaptive-tutor/src/app/api/explain/route.ts`. This is a NEW file — it does not exist yet.

```typescript
import { NextRequest, NextResponse } from "next/server";
import { generateText } from "@/lib/minimax-native";
import { explainAnswerPrompt } from "@/lib/prompts/index";
import type { ChatContext } from "@/lib/store";

export async function POST(req: NextRequest) {
  try {
    const body = await req.json() as {
      question: string;
      userAnswer: string;
      correctAnswer: string;
      feedback: string;
      conceptName: string;
      chatContext?: ChatContext;
    };

    const { question, userAnswer, correctAnswer, feedback, conceptName, chatContext } = body;

    if (!question || !userAnswer || !conceptName) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 });
    }

    const systemPrompt = explainAnswerPrompt({
      question,
      userAnswer,
      correctAnswer: correctAnswer ?? "",
      feedback: feedback ?? "",
      conceptName,
      chatContext,
    });

    const explanation = await generateText(
      [{ role: "user", content: "Please explain this." }],
      systemPrompt,
      { temperature: 0.5, maxTokens: 512 }
    );

    return NextResponse.json({ explanation });
  } catch (error) {
    console.error("[/api/explain] Error:", error);
    return NextResponse.json(
      { explanation: "I couldn't generate an explanation right now. Try again." },
      { status: 200 }  // Return 200 with fallback so UI doesn't show error state
    );
  }
}
```

IMPORTANT — check the `generateText` signature first by reading `lib/minimax-native.ts`. It takes `(messages, systemPrompt, options?)`. Adapt if the actual signature differs.

IMPORTANT — check the Next.js 16 pattern from Phase 6 SUMMARY: params are Promises in Next.js 16. This route has no params so that is not an issue here. Use standard App Router `POST(req: NextRequest)` signature.

Verify the route file is created: `ls adaptive-tutor/src/app/api/explain/`
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>curl -X POST http://localhost:3000/api/explain -H "Content-Type: application/json" -d '{"question":"What is mitosis?","userAnswer":"Cell growth","correctAnswer":"Cell division","feedback":"Incorrect","conceptName":"Mitosis"}' — should return { explanation: "..." }</manual>
  </verify>
  <done>File adaptive-tutor/src/app/api/explain/route.ts exists. TypeScript compiles without errors. Route accepts POST with question/userAnswer/correctAnswer/feedback/conceptName/chatContext body. Returns { explanation: string } on success, returns safe fallback on LLM failure (never 500 to client).</done>
</task>

<task type="auto">
  <name>Task 2: Extend Chat API to inject chatContext into system prompt</name>
  <files>adaptive-tutor/src/app/api/chat/route.ts</files>
  <action>
Read the current `/api/chat/route.ts` fully before editing. The file has a `chatSystemPrompt()` call that builds the system prompt. Extend it to include chatContext.

**Step 1 — Add import:**
```typescript
import { buildChatContextSnippet } from "@/lib/prompts/index";
import type { ChatContext } from "@/lib/store";
```
(Check existing imports — if prompts/index is already imported, just add to the destructure. If ChatContext import conflicts, use `import type`.)

**Step 2 — Extract chatContext from request body.** Find where the request body is parsed (the `await req.json()` call) and add `chatContext` to the destructure:
```typescript
const { ..., chatContext } = await req.json() as { ...; chatContext?: ChatContext };
```

**Step 3 — Pass chatContext snippet to the system prompt.** Find the `chatSystemPrompt(...)` call and add `chatContextSnippet`:
```typescript
const systemPrompt = chatSystemPrompt({
  ...,
  chatContextSnippet: chatContext ? buildChatContextSnippet(chatContext) : undefined,
});
```

**Step 4 — Extend chatSystemPrompt in prompts/index.ts** to accept and use the new parameter. Read the existing `chatSystemPrompt` function signature in `prompts/index.ts`. Add `chatContextSnippet?: string` to its context parameter object. At the end of the returned prompt string, append:
```typescript
if (context.chatContextSnippet) {
  return `${basePrompt}\n\n---\n${context.chatContextSnippet}`;
}
return basePrompt;
```
(Or however the function currently returns its string — adapt to its actual pattern.)

PITFALL to avoid (from RESEARCH.md Pitfall 2 and 6): The chat page must read chatContext from `useAppStore.getState().chatContext` at call time in its `handleSubmit`, NOT from a stale closure. Document this in a code comment in the route.ts to remind implementers that the context is only as fresh as what the client sends.

Verify TypeScript: `cd adaptive-tutor && npx tsc --noEmit 2>&1 | head -20`
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>In chat/page.tsx handleSubmit, add chatContext to POST body (temporary test) — confirm chat API logs show chatContextSnippet in the system prompt</manual>
  </verify>
  <done>TypeScript compiles without errors. /api/chat/route.ts accepts optional chatContext in request body. chatSystemPrompt() receives chatContextSnippet param and appends it to the system prompt when provided. prompts/index.ts chatSystemPrompt signature updated with chatContextSnippet?: string.</done>
</task>

<task type="auto">
  <name>Task 3: Add "Explain this" button and key-event context updates to Learn page</name>
  <files>adaptive-tutor/src/app/(tabs)/learn/page.tsx</files>
  <action>
Read learn/page.tsx fully before editing. This is the largest and most critical edit in this plan.

**Part A: Add key-event context updates in submitAttempt**

Inside the `submitAttempt` callback, after `setLastResult(result)` is called, add:
```typescript
// Update chatContext with this attempt — use direct store access to avoid stale closures
// (same pattern used for redirectedFromConceptId in this function)
const store = useAppStore.getState();
store.recordAttemptInContext({
  conceptId: result.proficiencyUpdate.conceptId,
  isCorrect: result.isCorrect,
  score: result.score ?? 0,
});
store.setChatContext({
  ...store.chatContext,
  activeConceptId: result.proficiencyUpdate.conceptId,
  activeUnitGraphId: store.activeUnitGraphId ?? undefined,
});
```

IMPORTANT: Use `useAppStore.getState()` (direct store access), NOT a hook subscription. The RESEARCH.md confirms this is the existing pattern in `submitAttempt` for `redirectedFromConceptId`. Do NOT add these as React hook dependencies.

**Part B: Add Explain this state variables**

Near other `useState` declarations at the top of the component, add:
```typescript
const [explainLoading, setExplainLoading] = useState(false);
const [explainText, setExplainText] = useState<string | null>(null);
```

**Part C: Add handleExplainThis handler**

Add this function inside the component, near other handlers like `handleAdvance`:
```typescript
async function handleExplainThis() {
  if (!currentQuestion || !lastResult) return;
  setExplainLoading(true);
  try {
    const res = await fetch("/api/explain", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        question: currentQuestion.questionText,
        userAnswer: textInput || selectedOption || "",
        correctAnswer: currentQuestion.correctAnswer ?? "",
        feedback: lastResult.feedback ?? "",
        conceptName: currentQuestion.conceptName ?? "",
        chatContext: useAppStore.getState().chatContext,
      }),
    });
    const data = await res.json() as { explanation: string };
    setExplainText(data.explanation);
  } catch {
    setExplainText("I couldn't generate an explanation right now. Try again.");
  } finally {
    setExplainLoading(false);
  }
}
```

Identify the correct field names for `textInput`, `selectedOption`, `currentQuestion.questionText`, `currentQuestion.correctAnswer`, `currentQuestion.conceptName` by reading the actual local state and question type in the file. Adapt field names to match exactly what exists in the file.

**Part D: Reset state in handleAdvance**

Find the `handleAdvance` function (or equivalent) that moves to the next question. Add before its main logic:
```typescript
setExplainText(null);
setExplainLoading(false);
```

**Part E: Render "Explain this" button and explanation block in feedback phase**

Find the feedback UI section (where `lastResult` is rendered). It is gated on `phase === "feedback"` (or similar). Inside that section, add the following block — ONLY when `!lastResult.isCorrect`:

```typescript
{!lastResult.isCorrect && (
  <div className="mt-3 flex flex-col gap-2">
    {!explainText && (
      <button
        onClick={handleExplainThis}
        disabled={explainLoading}
        className="flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium transition-opacity"
        style={{
          backgroundColor: "rgba(var(--primary-rgb, 99, 102, 241), 0.1)",
          color: "var(--primary, #6366f1)",
          border: "1px solid rgba(var(--primary-rgb, 99, 102, 241), 0.3)",
          opacity: explainLoading ? 0.6 : 1,
        }}
      >
        {explainLoading && <span className="inline-block w-3 h-3 border border-current border-t-transparent rounded-full animate-spin" />}
        {explainLoading ? "Thinking..." : "Explain this"}
      </button>
    )}
    {explainText && (
      <div
        className="rounded-xl border p-3 text-sm leading-relaxed"
        style={{
          backgroundColor: "var(--bg-card, rgba(255,255,255,0.05))",
          borderColor: "var(--border, rgba(255,255,255,0.1))",
          color: "var(--text-primary, inherit)",
        }}
      >
        {explainText}
      </div>
    )}
  </div>
)}
```

IMPORTANT NOTES:
- Check what CSS variables the project uses by reading an existing component like GapProposalCard.tsx — adapt the variable names to match
- If `Loader2` from lucide-react is already imported in this file, use it instead of the manual spinner
- The button must be BELOW the existing feedback content, not replacing it
- Gate the entire block on `!lastResult.isCorrect` (RESEARCH.md Pitfall 4)
- Do NOT block the feedback display to wait for the explanation (Pitfall from RESEARCH.md: "The feedback card must render immediately")

Verify TypeScript: `cd adaptive-tutor && npx tsc --noEmit 2>&1 | head -20`
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>
1. Start dev server: cd adaptive-tutor && npm run dev
2. Navigate to /learn, answer a question incorrectly
3. Confirm feedback card appears immediately (no delay)
4. Confirm "Explain this" button appears below feedback
5. Click "Explain this" — confirm loading spinner shows, then explanation text appears
6. Confirm button is NOT visible after correct answers
7. Click "Next" — confirm explanation text clears
    </manual>
  </verify>
  <done>learn/page.tsx has explainLoading/explainText state, handleExplainThis async handler, explanation block in feedback phase gated on !lastResult.isCorrect. submitAttempt calls recordAttemptInContext and setChatContext via useAppStore.getState() direct access. handleAdvance resets explainText and explainLoading to initial values. TypeScript compiles without errors.</done>
</task>

</tasks>

<verification>
Run full TypeScript check:
`cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -40`

Confirm new file exists:
`ls adaptive-tutor/src/app/api/explain/`

Confirm chat API imports buildChatContextSnippet:
`grep -n "buildChatContextSnippet" adaptive-tutor/src/app/api/chat/route.ts`

Confirm learn page has explain handler:
`grep -n "handleExplainThis\|explainText\|explainLoading" adaptive-tutor/src/app/(tabs)/learn/page.tsx`
</verification>

<success_criteria>
- /api/explain route exists and returns { explanation: string } for any valid POST body
- /api/chat route injects chatContext snippet into system prompt when chatContext is in request body
- learn/page.tsx shows "Explain this" button only after wrong answers
- Explanation appears below feedback card asynchronously (does not block feedback display)
- submitAttempt updates chatContext in store with each attempt result
- Advancing to next question clears the explanation block
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-integrated-chat-window/07-02-SUMMARY.md`
</output>
