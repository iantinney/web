---
phase: 07-integrated-chat-window
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - adaptive-tutor/src/app/api/advisor/route.ts
  - adaptive-tutor/src/components/AdvisorCards.tsx
  - adaptive-tutor/src/app/(tabs)/chat/page.tsx
  - adaptive-tutor/src/app/(tabs)/graph/page.tsx
autonomous: true
requirements:
  - CHAT-CONTEXT-05
  - CHAT-CONTEXT-06

must_haves:
  truths:
    - "Chat tab shows a 'What should I learn next?' quick-action button above the input field (only when a study plan is active)"
    - "Clicking the advisor button adds a user message and then an assistant message with 2-3 interactive recommendation cards"
    - "Each recommendation card shows a title, pitch, and 'Practice this' button"
    - "Clicking 'Practice this' on an advisor card sets the target concept and navigates to /learn"
    - "Clicking a concept node in the Graph tab updates chatContext.activeConceptId in the store"
    - "chatContext is sent in the POST body of chat handleSubmit, read fresh from the store at call time"
  artifacts:
    - path: "adaptive-tutor/src/app/api/advisor/route.ts"
      provides: "POST endpoint that queries DB state and returns 2-3 ranked AdvisorCard recommendations"
      exports: ["POST"]
    - path: "adaptive-tutor/src/components/AdvisorCards.tsx"
      provides: "React component rendering 2-3 AdvisorCard objects with Practice this navigation buttons"
      exports: ["AdvisorCards"]
    - path: "adaptive-tutor/src/app/(tabs)/chat/page.tsx"
      provides: "Advisor quick-action button, AdvisorCards message renderer, chatContext in handleSubmit POST body"
      contains: "handleAdvisor"
    - path: "adaptive-tutor/src/app/(tabs)/graph/page.tsx"
      provides: "setChatContext call when concept node is selected"
      contains: "setChatContext"
  key_links:
    - from: "adaptive-tutor/src/app/(tabs)/chat/page.tsx"
      to: "adaptive-tutor/src/app/api/advisor/route.ts"
      via: "fetch POST /api/advisor with chatContext body"
      pattern: "fetch.*api/advisor"
    - from: "adaptive-tutor/src/app/api/advisor/route.ts"
      to: "adaptive-tutor/src/lib/prompts/index.ts"
      via: "advisorPrompt() called to build structured recommendation prompt"
      pattern: "advisorPrompt"
    - from: "adaptive-tutor/src/components/AdvisorCards.tsx"
      to: "adaptive-tutor/src/lib/store.ts"
      via: "setTargetConceptId + router.push('/learn') for Practice this navigation"
      pattern: "setTargetConceptId"
    - from: "adaptive-tutor/src/app/(tabs)/chat/page.tsx"
      to: "adaptive-tutor/src/components/AdvisorCards.tsx"
      via: "Rendered when message.messageType === 'advisor_cards'"
      pattern: "AdvisorCards"
---

<objective>
Build the "What should I learn next?" advisor feature in the Chat tab, plus the concept-click context update in the Graph tab.

Purpose: Users get ranked, actionable learning recommendations on demand. The advisor analyzes the full learner state from the DB and returns interactive cards with a "Practice this" navigation button. Graph tab concept clicks also feed into chatContext so the chat tutor is aware of what the user was exploring.
Output: New /api/advisor route, new AdvisorCards component, modified chat/page.tsx (advisor button + card rendering + chatContext in POST), modified graph/page.tsx (activeConceptId update on node click).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-integrated-chat-window/07-CONTEXT.md
@.planning/phases/07-integrated-chat-window/07-RESEARCH.md
@.planning/phases/07-integrated-chat-window/07-01-SUMMARY.md
@adaptive-tutor/src/app/api/advisor/route.ts
@adaptive-tutor/src/components/AdvisorCards.tsx
@adaptive-tutor/src/app/(tabs)/chat/page.tsx
@adaptive-tutor/src/app/(tabs)/graph/page.tsx
@adaptive-tutor/src/app/api/chat/route.ts
@adaptive-tutor/src/lib/store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /api/advisor route</name>
  <files>adaptive-tutor/src/app/api/advisor/route.ts</files>
  <action>
Create a NEW file at `adaptive-tutor/src/app/api/advisor/route.ts`. This file does not exist yet.

The route queries the DB for learner state (same pattern as `/api/chat/route.ts` idle phase handler — read that file first to confirm the Prisma query pattern), calls advisorPrompt(), parses the LLM JSON response, and returns 2-3 AdvisorCard recommendations.

```typescript
import { NextRequest, NextResponse } from "next/server";
import { generateText } from "@/lib/minimax-native";
import { advisorPrompt } from "@/lib/prompts/index";
import { prisma } from "@/lib/db";
import type { ChatContext, AdvisorCard } from "@/lib/store";

export async function POST(req: NextRequest) {
  try {
    const userId = req.headers.get("x-user-id") ?? "demo-user";
    const body = await req.json() as { chatContext?: ChatContext };
    const { chatContext } = body;

    // Fetch learner state from DB (same pattern as /api/chat route)
    const studyPlans = await prisma.studyPlan.findMany({
      where: { userId },
      include: {
        unitGraphs: {
          include: {
            memberships: {
              include: { concept: true },
            },
          },
        },
      },
    });

    const recentAttempts = await prisma.attemptRecord.findMany({
      where: { userId },
      orderBy: { createdAt: "desc" },
      take: 10,
    });

    // Fetch gap detections across all study plans
    const gapDetections = await prisma.gapDetection.findMany({
      where: {
        studyPlan: { userId },
        status: "detected",
      },
      orderBy: { createdAt: "desc" },
    });

    // Build summary data for the prompt
    const activePlans = studyPlans.map((sp) => {
      const allConcepts = sp.unitGraphs.flatMap((g) => g.memberships.map((m) => m.concept));
      const masteredCount = allConcepts.filter((c) => (c.proficiency ?? 0) >= 0.8).length;
      const progress = allConcepts.length > 0 ? masteredCount / allConcepts.length : 0;
      return {
        title: sp.title ?? "Untitled Plan",
        conceptCount: allConcepts.length,
        progress,
      };
    });

    const graphConcepts = studyPlans
      .flatMap((sp) =>
        sp.unitGraphs.flatMap((g) =>
          g.memberships.map((m) => ({
            name: m.concept.name,
            proficiency: m.concept.proficiency ?? 0,
            isLocked: false, // simplified — lock state requires edge query
          }))
        )
      )
      .slice(0, 50); // cap to avoid token overflow

    const gapSummary = Object.values(
      gapDetections.reduce<Record<string, { missingConcept: string; occurrences: number }>>((acc, g) => {
        const key = g.missingConcept;
        if (!acc[key]) acc[key] = { missingConcept: key, occurrences: 0 };
        acc[key].occurrences++;
        return acc;
      }, {})
    );

    const recentAttemptsForPrompt = recentAttempts.map((a) => ({
      conceptId: a.conceptId,
      isCorrect: a.isCorrect,
      score: a.score ?? 0.5,
    }));

    const systemPrompt = advisorPrompt({
      activePlans,
      graphConcepts,
      recentAttempts: recentAttemptsForPrompt,
      gapDetections: gapSummary,
      chatContext,
    });

    const text = await generateText(
      [{ role: "user", content: "What should I learn next?" }],
      systemPrompt,
      { temperature: 0.3, maxTokens: 1024 }
    );

    // Parse LLM JSON response — guard against markdown fences (Pitfall 3 from RESEARCH.md)
    let recommendations: AdvisorCard[] = [];
    try {
      const cleaned = text.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
      recommendations = JSON.parse(cleaned) as AdvisorCard[];
    } catch {
      console.error("[/api/advisor] Failed to parse LLM response:", text);
      return NextResponse.json({
        recommendations: [
          {
            type: "continue",
            title: "Continue practicing",
            pitch: "Keep working through your current study plan.",
            priority: 1,
          },
        ],
      });
    }

    return NextResponse.json({ recommendations: recommendations.slice(0, 3) });
  } catch (error) {
    console.error("[/api/advisor] Error:", error);
    return NextResponse.json({ error: "Failed to generate recommendations" }, { status: 500 });
  }
}
```

CRITICAL — check actual Prisma schema fields before coding:
- Does `AttemptRecord` have `score`, `conceptId`, `isCorrect`? Read the schema: `cat adaptive-tutor/prisma/schema.prisma | grep -A 15 "model AttemptRecord"`
- Does `GapDetection` have `missingConcept`, `status`, `studyPlan` relation? Check: `cat adaptive-tutor/prisma/schema.prisma | grep -A 15 "model GapDetection"`
- Does `StudyPlan` have `unitGraphs` relation? Check schema.
- Does `Concept` have `proficiency` field? Check schema.
- Adapt the query to match actual schema — do NOT assume field names from this plan.

CRITICAL — check actual Prisma client import path: read an existing API route (like `/api/chat/route.ts`) to see how prisma is imported. Use `import { prisma } from "@/lib/db"` or adjust to the actual path.

Verify TypeScript: `cd adaptive-tutor && npx tsc --noEmit 2>&1 | head -20`
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>curl -X POST http://localhost:3000/api/advisor -H "Content-Type: application/json" -H "x-user-id: demo-user" -d '{"chatContext":{"mode":"practicing"}}' — should return { recommendations: [...] } with 1-3 items</manual>
  </verify>
  <done>adaptive-tutor/src/app/api/advisor/route.ts exists. TypeScript compiles without errors. POST endpoint queries DB for study plans, concepts, attempts, gap detections. Calls advisorPrompt() and parses JSON. Returns { recommendations: AdvisorCard[] } with up to 3 items. Handles JSON parse failure with safe fallback. Never crashes on malformed LLM output.</done>
</task>

<task type="auto">
  <name>Task 2: Create AdvisorCards component</name>
  <files>adaptive-tutor/src/components/AdvisorCards.tsx</files>
  <action>
Create a NEW file at `adaptive-tutor/src/components/AdvisorCards.tsx`. This file does not exist yet.

Read `adaptive-tutor/src/components/GapProposalCard.tsx` first to understand the CSS variable styling pattern used in this project (no shadcn/ui — ui/ directory is empty).

```typescript
"use client";

import { useRouter } from "next/navigation";
import { useAppStore } from "@/lib/store";
import type { AdvisorCard } from "@/lib/store";

// Icon labels per type — keep it text-based, no icon library needed
const TYPE_LABELS: Record<AdvisorCard["type"], string> = {
  review: "Review",
  continue: "Continue",
  remediate: "Fix Gap",
  extend: "Extend",
  bridge: "Bridge",
  new_domain: "New Topic",
};

// Subtle accent colors per type using CSS variables consistent with project
const TYPE_COLORS: Record<AdvisorCard["type"], string> = {
  review: "rgba(250, 204, 21, 0.15)",   // amber — spaced repetition
  continue: "rgba(34, 197, 94, 0.12)",  // green — forward progress
  remediate: "rgba(239, 68, 68, 0.12)", // red — fix a gap
  extend: "rgba(99, 102, 241, 0.12)",   // indigo — extend
  bridge: "rgba(168, 85, 247, 0.12)",   // purple — bridge
  new_domain: "rgba(14, 165, 233, 0.12)", // sky — new domain
};

interface AdvisorCardsProps {
  cards: AdvisorCard[];
}

export function AdvisorCards({ cards }: AdvisorCardsProps) {
  const router = useRouter();
  const setTargetConceptId = useAppStore((s) => s.setTargetConceptId);

  function handlePractice(card: AdvisorCard) {
    if (card.conceptId) {
      setTargetConceptId(card.conceptId);
    }
    router.push("/learn");
  }

  return (
    <div className="flex flex-col gap-2 mt-2">
      {cards.map((card, idx) => (
        <div
          key={`${card.type}-${idx}`}
          className="rounded-xl border p-3 flex flex-col gap-2"
          style={{
            backgroundColor: TYPE_COLORS[card.type] ?? "rgba(255,255,255,0.05)",
            borderColor: "var(--border, rgba(255,255,255,0.1))",
          }}
        >
          <div className="flex items-center gap-2">
            <span
              className="text-xs font-semibold px-2 py-0.5 rounded-full"
              style={{
                backgroundColor: "rgba(255,255,255,0.1)",
                color: "var(--text-secondary, rgba(255,255,255,0.6))",
              }}
            >
              {TYPE_LABELS[card.type] ?? card.type}
            </span>
            <span
              className="font-semibold text-sm"
              style={{ color: "var(--text-primary, inherit)" }}
            >
              {card.title}
            </span>
          </div>
          <p
            className="text-sm leading-relaxed"
            style={{ color: "var(--text-secondary, rgba(255,255,255,0.7))" }}
          >
            {card.pitch}
          </p>
          {card.conceptId && (
            <button
              onClick={() => handlePractice(card)}
              className="self-start text-sm font-medium px-3 py-1.5 rounded-lg transition-opacity hover:opacity-80"
              style={{
                backgroundColor: "rgba(99, 102, 241, 0.2)",
                color: "var(--primary, #6366f1)",
                border: "1px solid rgba(99, 102, 241, 0.4)",
              }}
            >
              Practice this
            </button>
          )}
        </div>
      ))}
    </div>
  );
}
```

IMPORTANT: Check if `setTargetConceptId` exists in the store (from plan 06-02 which added `redirectedFromConceptId`). Read `adaptive-tutor/src/lib/store.ts` to verify what actions exist for targeting a concept for practice. If the action is named differently (e.g., `setActiveConceptId`, `setPracticeTarget`), adapt to the actual name.

IMPORTANT: Adapt CSS variable names to match GapProposalCard.tsx's actual vars — check that file before finalizing.

Verify TypeScript: `cd adaptive-tutor && npx tsc --noEmit 2>&1 | head -20`
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Component should be renderable — will be tested end-to-end in Task 3</manual>
  </verify>
  <done>adaptive-tutor/src/components/AdvisorCards.tsx exists. Accepts cards: AdvisorCard[] prop. Renders one card per recommendation with type label, title, pitch, and optional "Practice this" button. "Practice this" calls setTargetConceptId + router.push("/learn"). Uses CSS variables consistent with GapProposalCard styling. TypeScript compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 3: Wire advisor button in Chat page and activeConceptId update in Graph page</name>
  <files>
    adaptive-tutor/src/app/(tabs)/chat/page.tsx
    adaptive-tutor/src/app/(tabs)/graph/page.tsx
  </files>
  <action>
Read both chat/page.tsx and graph/page.tsx fully before editing.

**PART A: chat/page.tsx changes**

**A1 — Import AdvisorCards:**
```typescript
import { AdvisorCards } from "@/components/AdvisorCards";
```

**A2 — Add handleAdvisor function** inside the component (near other handlers like `handleSubmit`):
```typescript
async function handleAdvisor() {
  if (isLoading) return;
  setIsLoading(true);
  // Add user message
  addChatMessage({
    id: crypto.randomUUID(),
    role: "user",
    content: "What should I learn next?",
  });
  try {
    const res = await fetch("/api/advisor", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-user-id": getUserId(), // use same getUserId() pattern as existing handleSubmit
      },
      body: JSON.stringify({
        chatContext: useAppStore.getState().chatContext, // direct store access — avoids stale closure
      }),
    });
    const data = await res.json() as { recommendations: AdvisorCard[]; error?: string };
    if (data.error) throw new Error(data.error);
    addChatMessage({
      id: crypto.randomUUID(),
      role: "assistant",
      content: "Here are my recommendations for what to learn next:",
      messageType: "advisor_cards",
      advisorCards: data.recommendations,
    });
  } catch {
    addChatMessage({
      id: crypto.randomUUID(),
      role: "assistant",
      content: "Sorry, I couldn't generate recommendations right now. Try again.",
    });
  } finally {
    setIsLoading(false);
  }
}
```

Find the correct function/variable names by reading the file: `getUserId()` may be named differently. `addChatMessage` may be from the store. `isLoading` may be named `loading`. Adapt all names to match exactly what exists in the file.

**A3 — Add advisor quick-action button** in the input area above the text input (not inside the message list). Find the section in the JSX where the input field is rendered. Add BEFORE the input field:

```typescript
{/* Advisor quick-action — only show when study plan is active */}
{activeStudyPlanId && (
  <button
    onClick={handleAdvisor}
    disabled={isLoading}
    className="flex items-center gap-1.5 px-3 py-1.5 rounded-full text-xs font-medium transition-opacity mb-2 self-start"
    style={{
      backgroundColor: "rgba(99, 102, 241, 0.1)",
      color: "var(--primary, #6366f1)",
      border: "1px solid rgba(99, 102, 241, 0.3)",
      opacity: isLoading ? 0.5 : 1,
    }}
  >
    What should I learn next?
  </button>
)}
```

Check that `activeStudyPlanId` is available in the component (from Zustand store). If not, add it: `const activeStudyPlanId = useAppStore((s) => s.activeStudyPlanId)`.

**A4 — Extend message renderer** to handle messageType === "advisor_cards". Find the JSX where messages are mapped/rendered. For each message, add a conditional:
```typescript
{msg.messageType === "advisor_cards" && msg.advisorCards && msg.advisorCards.length > 0 ? (
  <div>
    <p className="text-sm mb-1">{msg.content}</p>
    <AdvisorCards cards={msg.advisorCards} />
  </div>
) : (
  // existing message content rendering
  <span>{msg.content}</span>
)}
```
Adapt to the actual rendering structure in the file — the goal is to show AdvisorCards for advisor_cards messages and normal text for all other messages.

**A5 — Send chatContext in handleSubmit POST body.** Find the existing `handleSubmit` function (or equivalent). Find where the POST body is constructed for `/api/chat`. Add `chatContext` to the body:
```typescript
body: JSON.stringify({
  // ... existing fields ...
  chatContext: useAppStore.getState().chatContext, // always read fresh from store
}),
```
Use `useAppStore.getState().chatContext` (direct access), NOT a hook-destructured value. This avoids the stale closure pitfall documented in RESEARCH.md Pitfall 6.

**PART B: graph/page.tsx changes**

Find the graph page's concept node click handler (where `selectedConcept` or `onNodeClick` is handled). After setting the selected concept, add:
```typescript
// Update chatContext so chat tab knows which concept was explored
useAppStore.getState().setChatContext({
  ...useAppStore.getState().chatContext,
  activeConceptId: selectedConcept.id,
});
```

If the click handler uses a React state setter like `setSelectedConcept`, add the chatContext update immediately after. Use direct store access `useAppStore.getState()` to avoid stale closures.

Verify TypeScript: `cd adaptive-tutor && npx tsc --noEmit 2>&1 | head -20`
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>
1. Start dev server: cd adaptive-tutor && npm run dev
2. Navigate to /chat — confirm "What should I learn next?" button appears above input (only if study plan active)
3. Click the button — confirm user message appears, then 2-3 recommendation cards appear
4. If a card has "Practice this" button, click it — confirm navigation to /learn
5. Navigate to /graph, click a concept node — open browser devtools, check Zustand store, confirm chatContext.activeConceptId updated
6. Navigate to /chat, send a message — check network tab POST to /api/chat contains chatContext in body
    </manual>
  </verify>
  <done>chat/page.tsx has handleAdvisor function, advisor button above input (gated on activeStudyPlanId), AdvisorCards rendered for advisor_cards messages, chatContext in handleSubmit POST body. graph/page.tsx updates chatContext.activeConceptId on concept node click. TypeScript compiles without errors.</done>
</task>

</tasks>

<verification>
Run full TypeScript check:
`cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -40`

Confirm new files exist:
`ls adaptive-tutor/src/app/api/advisor/ && ls adaptive-tutor/src/components/AdvisorCards.tsx`

Confirm chat page imports AdvisorCards:
`grep -n "AdvisorCards\|handleAdvisor\|advisor_cards" adaptive-tutor/src/app/\(tabs\)/chat/page.tsx`

Confirm graph page updates chatContext:
`grep -n "setChatContext\|chatContext" adaptive-tutor/src/app/\(tabs\)/graph/page.tsx`
</verification>

<success_criteria>
- /api/advisor route exists, queries DB, calls advisorPrompt(), returns { recommendations: AdvisorCard[] }
- AdvisorCards component renders recommendation cards with type label, title, pitch, "Practice this" button
- Chat page shows advisor quick-action button when activeStudyPlanId is set
- Clicking advisor button triggers /api/advisor call and renders AdvisorCards in message list
- Clicking "Practice this" navigates to /learn with targetConceptId set
- graph/page.tsx updates chatContext.activeConceptId when concept node is clicked
- chat/page.tsx handleSubmit sends chatContext in POST body using direct store access
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-integrated-chat-window/07-03-SUMMARY.md`
</output>
