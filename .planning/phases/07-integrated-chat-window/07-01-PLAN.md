---
phase: 07-integrated-chat-window
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - adaptive-tutor/src/lib/store.ts
  - adaptive-tutor/src/lib/prompts/index.ts
  - adaptive-tutor/src/app/(tabs)/layout.tsx
autonomous: true
requirements:
  - CHAT-CONTEXT-01
  - CHAT-CONTEXT-02

must_haves:
  truths:
    - "chatContext field exists in Zustand store with mode/activeConceptId/activeUnitGraphId/recentAttempts"
    - "Switching to Learn tab sets mode to 'practicing', Graph tab sets 'exploring', Chat tab sets 'planning'"
    - "buildChatContextSnippet() produces a 50-100 token string from a ChatContext object"
    - "explainAnswerPrompt() produces a Socratic tutor prompt given question/answer/concept data"
    - "advisorPrompt() produces a JSON-only structured prompt for ranked next-step recommendations"
    - "AdvisorCard and ChatMessage types exported from store.ts with messageType discriminated union"
  artifacts:
    - path: "adaptive-tutor/src/lib/store.ts"
      provides: "ChatContext interface, AdvisorCard interface, chatContext field, setChatContext/updateChatContextMode/recordAttemptInContext actions, ChatMessage extended with messageType/advisorCards"
      exports: ["ChatContext", "AdvisorCard", "chatContext"]
    - path: "adaptive-tutor/src/lib/prompts/index.ts"
      provides: "buildChatContextSnippet, explainAnswerPrompt, advisorPrompt utility functions"
      exports: ["buildChatContextSnippet", "explainAnswerPrompt", "advisorPrompt"]
    - path: "adaptive-tutor/src/app/(tabs)/layout.tsx"
      provides: "Tab-switch mode update via useEffect watching usePathname()"
      contains: "updateChatContextMode"
  key_links:
    - from: "adaptive-tutor/src/app/(tabs)/layout.tsx"
      to: "adaptive-tutor/src/lib/store.ts"
      via: "useAppStore updateChatContextMode called in useEffect on pathname change"
      pattern: "updateChatContextMode"
    - from: "adaptive-tutor/src/lib/prompts/index.ts"
      to: "adaptive-tutor/src/lib/store.ts"
      via: "ChatContext type import used in all new prompt functions"
      pattern: "ChatContext"
---

<objective>
Establish the shared foundation for Phase 7: add the chatContext Zustand field (with types and actions), extend the ChatMessage type for advisor cards, add all three prompt utility functions, and wire tab-switch mode updates in the layout.

Purpose: Every downstream feature in Phase 7 reads chatContext from the store and uses one of the three prompt utilities. This plan creates those shared exports so Plans 02 and 03 can work in parallel against a stable interface.
Output: Extended store.ts (ChatContext field + AdvisorCard type + ChatMessage extension), extended prompts/index.ts (3 new functions), updated layout.tsx (mode update on tab switch).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-integrated-chat-window/07-CONTEXT.md
@.planning/phases/07-integrated-chat-window/07-RESEARCH.md
@adaptive-tutor/src/lib/store.ts
@adaptive-tutor/src/lib/prompts/index.ts
@adaptive-tutor/src/app/(tabs)/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Zustand store with chatContext field, AdvisorCard type, and ChatMessage extension</name>
  <files>adaptive-tutor/src/lib/store.ts</files>
  <action>
Read the current store.ts fully before editing. Then make these additions:

**Step 1 — Add new interfaces near the top of the file (after existing imports, before AppState):**

```typescript
export interface ChatContext {
  mode: "idle" | "practicing" | "exploring" | "planning";
  activeConceptId?: string;
  activeUnitGraphId?: string;
  recentAttempts?: {
    conceptId: string;
    isCorrect: boolean;
    score: number;
  }[];
}

export interface AdvisorCard {
  type: "review" | "continue" | "remediate" | "extend" | "bridge" | "new_domain";
  title: string;
  pitch: string;
  conceptId?: string;
  unitGraphId?: string;
  priority: number;
}
```

**Step 2 — Extend the existing ChatMessage interface** (find it in store.ts, it already has id/role/content) to add:
```typescript
messageType?: "text" | "advisor_cards";
advisorCards?: AdvisorCard[];
```

**Step 3 — Add chatContext to the AppState interface:**
```typescript
chatContext: ChatContext;
setChatContext: (ctx: ChatContext) => void;
updateChatContextMode: (mode: ChatContext["mode"]) => void;
recordAttemptInContext: (attempt: { conceptId: string; isCorrect: boolean; score: number }) => void;
```

**Step 4 — Add initial state in the Zustand `create()` call:**
```typescript
chatContext: { mode: "idle" },
```

**Step 5 — Add action implementations in the Zustand `create()` call:**
```typescript
setChatContext: (ctx) => set({ chatContext: ctx }),
updateChatContextMode: (mode) =>
  set((state) => ({ chatContext: { ...state.chatContext, mode } })),
recordAttemptInContext: (attempt) =>
  set((state) => ({
    chatContext: {
      ...state.chatContext,
      recentAttempts: [
        attempt,
        ...(state.chatContext.recentAttempts ?? []),
      ].slice(0, 5),
    },
  })),
```

IMPORTANT PATTERNS from existing codebase (do not deviate):
- The store uses Zustand 5 with `create<AppState>()(persist(...))` — add new fields alongside existing ones, do not restructure
- `useAppStore.getState()` direct access pattern is already used in learn/page.tsx submitAttempt — the new actions follow this same approach
- Do NOT clear activeConceptId/activeUnitGraphId/recentAttempts when updateChatContextMode is called — only update `mode`
- Verify TypeScript compiles after changes: `cd adaptive-tutor && npx tsc --noEmit 2>&1 | head -20`
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Confirm store.ts exports ChatContext, AdvisorCard interfaces and chatContext field is present in initial state</manual>
  </verify>
  <done>TypeScript compiles without errors related to store.ts. ChatContext, AdvisorCard types exported. chatContext field initialized as { mode: "idle" }. ChatMessage interface has messageType and advisorCards fields. All three actions (setChatContext, updateChatContextMode, recordAttemptInContext) implemented.</done>
</task>

<task type="auto">
  <name>Task 2: Add prompt utility functions to lib/prompts/index.ts</name>
  <files>adaptive-tutor/src/lib/prompts/index.ts</files>
  <action>
Read prompts/index.ts fully before editing. Then append three new exported functions at the end of the file.

**Function 1: buildChatContextSnippet**
```typescript
export function buildChatContextSnippet(ctx: ChatContext): string {
  const lines: string[] = [`USER CURRENT ACTIVITY: ${ctx.mode}`];
  if (ctx.activeConceptId) {
    lines.push(`Active concept ID: ${ctx.activeConceptId}`);
  }
  if (ctx.activeUnitGraphId) {
    lines.push(`Active graph ID: ${ctx.activeUnitGraphId}`);
  }
  if (ctx.recentAttempts && ctx.recentAttempts.length > 0) {
    const wrongCount = ctx.recentAttempts.filter((a) => !a.isCorrect).length;
    lines.push(
      `Recent attempts: ${ctx.recentAttempts.length} total, ${wrongCount} incorrect`
    );
    if (wrongCount >= 2) {
      lines.push("Note: User is struggling — proactively offer to explain.");
    }
  }
  return lines.join("\n");
}
```

**Function 2: explainAnswerPrompt**
```typescript
export function explainAnswerPrompt(ctx: {
  question: string;
  userAnswer: string;
  correctAnswer: string;
  feedback: string;
  conceptName: string;
  chatContext?: ChatContext;
}): string {
  const contextNote = ctx.chatContext?.recentAttempts
    ? `The learner has answered ${ctx.chatContext.recentAttempts.length} recent questions, with ${ctx.chatContext.recentAttempts.filter((a) => !a.isCorrect).length} incorrect.`
    : "";

  return `You are a patient, Socratic tutor. A student just answered a question incorrectly.

CONCEPT: ${ctx.conceptName}
QUESTION: ${ctx.question}
STUDENT'S ANSWER: ${ctx.userAnswer}
CORRECT ANSWER: ${ctx.correctAnswer}
FEEDBACK GIVEN: ${ctx.feedback}
${contextNote}

Explain IN 2-4 SENTENCES:
1. Why the student's answer was wrong (without being harsh)
2. The correct way to think about it
3. A memory anchor or intuition to help them remember

Be warm, specific, and concrete. Avoid jargon. Do not repeat the question verbatim.`;
}
```

**Function 3: advisorPrompt**
```typescript
export function advisorPrompt(ctx: {
  activePlans: { title: string; conceptCount: number; progress: number }[];
  graphConcepts: { name: string; proficiency: number; isLocked: boolean }[];
  recentAttempts: { conceptId: string; isCorrect: boolean; score: number }[];
  gapDetections: { missingConcept: string; occurrences: number }[];
  chatContext?: ChatContext;
}): string {
  const plansText = ctx.activePlans
    .map((p) => `- "${p.title}": ${p.conceptCount} concepts, ${Math.round(p.progress * 100)}% complete`)
    .join("\n") || "No active study plans.";

  const masteredCount = ctx.graphConcepts.filter((c) => c.proficiency >= 0.8).length;
  const weakConcepts = ctx.graphConcepts
    .filter((c) => c.proficiency < 0.4 && !c.isLocked)
    .sort((a, b) => a.proficiency - b.proficiency)
    .slice(0, 5)
    .map((c) => `  - ${c.name} (proficiency: ${c.proficiency.toFixed(2)})`)
    .join("\n");

  const recentWrong = ctx.recentAttempts.filter((a) => !a.isCorrect).length;
  const gapText = ctx.gapDetections.length > 0
    ? ctx.gapDetections.map((g) => `- Missing: ${g.missingConcept} (${g.occurrences} occurrences)`).join("\n")
    : "No gap patterns detected.";

  const activityNote = ctx.chatContext
    ? `Current user activity: ${ctx.chatContext.mode}`
    : "";

  return `You are an adaptive learning advisor. Analyze this learner's current state and provide exactly 2-3 ranked recommendations for what they should study next.

STUDY PLANS:
${plansText}

CONCEPTS: ${ctx.graphConcepts.length} total, ${masteredCount} mastered
Weakest unlocked concepts:
${weakConcepts || "  (none — all concepts are strong or locked)"}

RECENT ACTIVITY: ${ctx.recentAttempts.length} attempts, ${recentWrong} incorrect
${activityNote}

GAP DETECTIONS:
${gapText}

OUTPUT ONLY VALID JSON — no markdown fences, no preamble, no postamble. Return a JSON array of 2-3 recommendation objects:
[
  {
    "type": "review" | "continue" | "remediate" | "extend" | "bridge" | "new_domain",
    "title": "Short actionable title (max 8 words)",
    "pitch": "One sentence explaining why this is the best next step",
    "conceptId": "concept-uuid-if-applicable-or-null",
    "unitGraphId": "graph-uuid-if-applicable-or-null",
    "priority": 1
  }
]

Rank by learning impact. Priority 1 = highest. Types: "review" = spaced repetition due concept, "remediate" = fix a detected gap, "continue" = next unlocked concept, "extend" = beyond current graph, "bridge" = connect to another graph, "new_domain" = start new topic.`;
}
```

Import `ChatContext` at the top of the file — add it to the existing import from `@/lib/store` (or wherever types are imported). If ChatContext is not yet imported, add:
```typescript
import type { ChatContext } from "@/lib/store";
```

Verify TypeScript compiles: `cd adaptive-tutor && npx tsc --noEmit 2>&1 | head -20`
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Check prompts/index.ts exports buildChatContextSnippet, explainAnswerPrompt, advisorPrompt</manual>
  </verify>
  <done>TypeScript compiles without errors. All three functions exported from prompts/index.ts. buildChatContextSnippet returns a multi-line string with mode, optional concept/graph IDs, and struggle note. explainAnswerPrompt returns a Socratic tutor prompt with question/answer/feedback context. advisorPrompt returns a JSON-only prompt with learner state and OUTPUT-ONLY-VALID-JSON instruction.</done>
</task>

<task type="auto">
  <name>Task 3: Wire tab-switch mode updates in layout.tsx</name>
  <files>adaptive-tutor/src/app/(tabs)/layout.tsx</files>
  <action>
Read layout.tsx fully before editing. The file already imports `usePathname`. Add the following:

**Step 1 — Add import for useAppStore:**
```typescript
import { useAppStore } from "@/lib/store";
```

**Step 2 — Inside the layout component, add the store action selector:**
```typescript
const updateChatContextMode = useAppStore((s) => s.updateChatContextMode);
```

**Step 3 — Add useEffect for pathname-to-mode mapping (after existing useEffect if any, before return):**
```typescript
useEffect(() => {
  const modeMap: Record<string, "practicing" | "exploring" | "planning" | "idle"> = {
    "/learn": "practicing",
    "/graph": "exploring",
    "/chat": "planning",
  };
  updateChatContextMode(modeMap[pathname] ?? "idle");
}, [pathname, updateChatContextMode]);
```

CRITICAL: Add `useEffect` to imports if not already imported. Check the existing imports at the top — add `useEffect` from "react" if not there.

IMPORTANT: Do NOT clear activeConceptId or recentAttempts when the mode updates. The updateChatContextMode action in the store only updates `mode`, leaving all other fields intact. This is intentional — a user who switches from Learn to Chat should still have their activeConceptId visible to the chat system prompt.

After editing, verify TypeScript compiles: `cd adaptive-tutor && npx tsc --noEmit 2>&1 | head -20`
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Navigate between tabs in browser — confirm chatContext.mode updates by checking Zustand devtools or adding a temporary console.log in updateChatContextMode</manual>
  </verify>
  <done>TypeScript compiles without errors. layout.tsx imports useAppStore and calls updateChatContextMode in a useEffect watching pathname. Mode mapping: /learn → "practicing", /graph → "exploring", /chat → "planning", other → "idle".</done>
</task>

</tasks>

<verification>
Run TypeScript type check across the whole project:
`cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -40`

Expected: Zero errors related to store.ts, prompts/index.ts, or layout.tsx.

Confirm exported symbols exist:
- `grep -n "ChatContext\|AdvisorCard\|chatContext\|updateChatContextMode\|recordAttemptInContext" adaptive-tutor/src/lib/store.ts | head -20`
- `grep -n "buildChatContextSnippet\|explainAnswerPrompt\|advisorPrompt" adaptive-tutor/src/lib/prompts/index.ts`
- `grep -n "updateChatContextMode" adaptive-tutor/src/app/\(tabs\)/layout.tsx`
</verification>

<success_criteria>
- store.ts exports ChatContext interface, AdvisorCard interface, chatContext field, setChatContext/updateChatContextMode/recordAttemptInContext actions
- ChatMessage interface in store.ts extended with messageType?: "text" | "advisor_cards" and advisorCards?: AdvisorCard[]
- prompts/index.ts exports buildChatContextSnippet, explainAnswerPrompt, advisorPrompt
- layout.tsx calls updateChatContextMode on every tab navigation
- Zero TypeScript errors across the project
</success_criteria>

<output>
After completion, create `.planning/phases/07-integrated-chat-window/07-01-SUMMARY.md`
</output>
