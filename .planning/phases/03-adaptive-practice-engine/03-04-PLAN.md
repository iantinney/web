---
phase: 03-adaptive-practice-engine
plan: "04"
type: execute
wave: 2
depends_on:
  - "03-01"
  - "03-02"
files_modified:
  - adaptive-tutor/src/app/api/study-plans/[id]/attempt/route.ts
  - adaptive-tutor/src/app/api/study-plans/[id]/session/route.ts
autonomous: true
requirements:
  - LEARN-05
  - LEARN-07

must_haves:
  truths:
    - "POST /attempt evaluates MCQ/fill_blank/flashcard rule-based (no LLM); free_response records answer only and marks isCorrect=false for phase 3"
    - "POST /attempt uses Prisma $transaction to atomically write AttemptRecord + update ConceptNode proficiency, confidence, easeFactor, interval, nextDue, lastPracticed"
    - "POST /attempt returns { isCorrect, feedback, explanation, score, proficiencyUpdate, sessionUpdate, sessionComplete }"
    - "GET /session returns current or new session for the study plan with questionsAttempted and questionsCorrect counts"
    - "POST /session/end sets endTime on the SessionRecord"
    - "Session stats (questionsAttempted, questionsCorrect) increment correctly on each attempt"
  artifacts:
    - path: "adaptive-tutor/src/app/api/study-plans/[id]/attempt/route.ts"
      provides: "POST endpoint: evaluate answer, update proficiency via SM-2 + proficiency.ts, record attempt"
      exports: ["POST"]
    - path: "adaptive-tutor/src/app/api/study-plans/[id]/session/route.ts"
      provides: "GET (get/create session) and PATCH (end session) endpoints"
      exports: ["GET", "PATCH"]
  key_links:
    - from: "adaptive-tutor/src/app/api/study-plans/[id]/attempt/route.ts"
      to: "prisma.$transaction"
      via: "atomic write of AttemptRecord + ConceptNode update"
      pattern: "prisma\\.\\$transaction"
    - from: "adaptive-tutor/src/app/api/study-plans/[id]/attempt/route.ts"
      to: "adaptive-tutor/src/lib/algorithms/sm2.ts"
      via: "import updateSM2 and getNextDueDate"
      pattern: "updateSM2|getNextDueDate"
    - from: "adaptive-tutor/src/app/api/study-plans/[id]/attempt/route.ts"
      to: "adaptive-tutor/src/lib/algorithms/proficiency.ts"
      via: "import updateProficiencyFromAttempt"
      pattern: "updateProficiencyFromAttempt"
---

<objective>
Build the attempt recording endpoint (the core of the practice loop) and session management endpoints.

Purpose: POST /attempt is the hot path — every question submission goes through it. It must be atomic (Prisma $transaction), fast for rule-based question types, and correct in its SM-2 + proficiency update calculations. GET/PATCH /session track the session container that groups attempts.
Output: attempt/route.ts and session/route.ts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@adaptive-tutor/phase3tech/PHASE3-API-SPEC.md
@adaptive-tutor/phase3tech/PHASE3-TECHNICAL-SPEC.md
@adaptive-tutor/src/lib/algorithms/sm2.ts
@adaptive-tutor/src/lib/algorithms/proficiency.ts
@adaptive-tutor/src/app/api/study-plans/[id]/route.ts
@adaptive-tutor/src/lib/types.ts
@adaptive-tutor/src/lib/prisma.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: POST /attempt — rule-based evaluation + SM-2 + proficiency update in $transaction</name>
  <files>adaptive-tutor/src/app/api/study-plans/[id]/attempt/route.ts</files>
  <action>
    Create the attempt POST endpoint. This is the most complex route in Phase 3.

    ```typescript
    // adaptive-tutor/src/app/api/study-plans/[id]/attempt/route.ts
    import { NextRequest, NextResponse } from "next/server";
    import { prisma } from "@/lib/prisma";
    import { updateSM2, getNextDueDate, userAnswerToQuality } from "@/lib/algorithms/sm2";
    import { updateProficiencyFromAttempt } from "@/lib/algorithms/proficiency";

    export async function POST(
      req: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      const { id } = await params;  // MUST await params (Next.js 16)

      const body = await req.json().catch(() => null);
      if (!body || !body.questionId || body.userAnswer === undefined || body.timeTaken === undefined) {
        return NextResponse.json({ error: "Missing required fields: questionId, userAnswer, timeTaken" }, { status: 400 });
      }

      const { questionId, userAnswer, timeTaken, sessionId } = body as {
        questionId: string;
        userAnswer: string;
        timeTaken: number;
        sessionId?: string;
      };

      // 1. Load question with its concept
      const question = await prisma.question.findUnique({
        where: { id: questionId },
        include: { conceptNode: true },
      });
      if (!question) {
        return NextResponse.json({ error: "Question not found", code: "QUESTION_NOT_FOUND" }, { status: 404 });
      }
      if (question.conceptNode.studyPlanId !== id) {
        return NextResponse.json({ error: "Question belongs to different study plan" }, { status: 400 });
      }

      const concept = question.conceptNode;

      // 2. Evaluate correctness — rule-based for all types except free_response
      let isCorrect = false;
      let feedback = "";
      let score = 0.0;

      if (question.questionType === "free_response") {
        // Phase 3: record only, no LLM evaluation. Mark as not evaluated.
        isCorrect = false; // neutral — won't penalize proficiency heavily
        feedback = "Answer recorded. AI evaluation coming in Phase 4.";
        score = 0.5; // neutral score for free response in phase 3
      } else if (question.questionType === "flashcard") {
        // Flashcard: user self-reports via "Got it!" / "Missed it" buttons
        // userAnswer is "correct" or "incorrect" from the UI
        isCorrect = userAnswer.toLowerCase() === "correct" || userAnswer.toLowerCase() === "got_it";
        feedback = isCorrect ? "Great! You remembered." : "Keep practicing — it'll come.";
        score = isCorrect ? 1.0 : 0.0;
      } else {
        // MCQ and fill_blank: string comparison (case-insensitive, trimmed)
        const normalized = userAnswer.trim().toLowerCase();
        const correct = question.correctAnswer.trim().toLowerCase();
        isCorrect = normalized === correct;
        feedback = isCorrect ? "Correct!" : `Not quite. The correct answer is: ${question.correctAnswer}`;
        score = isCorrect ? 1.0 : 0.0;
      }

      // 3. SM-2 quality score from isCorrect + timeTaken
      const quality = userAnswerToQuality(isCorrect, timeTaken);

      // 4. SM-2 state update
      const currentSM2 = {
        easeFactor: concept.easeFactor,
        interval: concept.interval,
        repetitionCount: concept.repetitionCount,
      };
      const newSM2 = updateSM2(currentSM2, quality);
      const nextDue = getNextDueDate(newSM2.interval);

      // 5. Proficiency update
      const difficultyTier = concept.difficultyTier as 1 | 2 | 3;
      // free_response in phase 3 uses neutral — don't update proficiency
      const { proficiency: newProficiency, confidence: newConfidence } =
        question.questionType === "free_response"
          ? { proficiency: concept.proficiency, confidence: concept.confidence }
          : updateProficiencyFromAttempt(concept.proficiency, concept.confidence, isCorrect, difficultyTier);

      // 6. Get or create session
      let session = sessionId
        ? await prisma.sessionRecord.findUnique({ where: { id: sessionId } })
        : await prisma.sessionRecord.findFirst({
            where: { studyPlanId: id, endTime: null },
            orderBy: { startTime: "desc" },
          });

      if (!session) {
        session = await prisma.sessionRecord.create({
          data: { studyPlanId: id, sessionType: "practice" },
        });
      }

      // 7. Atomic transaction: write AttemptRecord + update ConceptNode + update SessionRecord
      const [attempt, updatedSession] = await prisma.$transaction([
        prisma.attemptRecord.create({
          data: {
            questionId,
            userId: "demo-user", // single-user demo
            userAnswer: String(userAnswer),
            isCorrect,
            score,
            feedback,
            timeTaken,
            sessionId: session.id,
          },
        }),
        prisma.conceptNode.update({
          where: { id: concept.id },
          data: {
            proficiency: newProficiency,
            confidence: newConfidence,
            easeFactor: newSM2.easeFactor,
            interval: newSM2.interval,
            repetitionCount: newSM2.repetitionCount,
            nextDue,
            lastPracticed: new Date(),
            attemptCount: { increment: 1 },
          },
        }),
        prisma.sessionRecord.update({
          where: { id: session.id },
          data: {
            questionsAttempted: { increment: 1 },
            ...(isCorrect && { questionsCorrect: { increment: 1 } }),
            conceptsCoveredJson: JSON.stringify(
              [...new Set([
                ...JSON.parse(session.conceptsCoveredJson || "[]"),
                concept.id,
              ])]
            ),
          },
        }),
      ]);

      const finalSession = updatedSession;
      const accuracy = finalSession.questionsAttempted > 0
        ? finalSession.questionsCorrect / finalSession.questionsAttempted
        : 0;

      return NextResponse.json({
        isCorrect,
        feedback,
        explanation: question.explanation || null,
        score,
        proficiencyUpdate: {
          conceptId: concept.id,
          previousProficiency: concept.proficiency,
          newProficiency,
          previousConfidence: concept.confidence,
          newConfidence,
        },
        sessionUpdate: {
          sessionId: finalSession.id,
          questionsAttempted: finalSession.questionsAttempted,
          questionsCorrect: finalSession.questionsCorrect,
          accuracy,
        },
        sessionComplete: false, // UI determines completion by exhausting its question list
      });
    }
    ```

    Key implementation notes:
    - `await params` at top — Next.js 16
    - Prisma `$transaction` is MANDATORY for atomic writes (locked decision)
    - SM-2 and proficiency updates imported from the functions built in 03-01 and 03-02
    - free_response: neutral score + no proficiency change in Phase 3 (LLM eval is Phase 4)
    - flashcard: userAnswer is "correct"/"got_it" or "incorrect"/"missed_it" string from UI
    - MCQ/fill_blank: case-insensitive trimmed string comparison
    - userId hardcoded to "demo-user" (single-user demo per STATE.md decisions)
    - `store.getState()` — N/A here (server-side route); the NOTE about store.getState() applies to async client handlers, not API routes
    - sessionComplete always false — UI manages session flow by tracking its own question list
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -10</automated>
    <manual>After generating questions (03-03), submit a correct MCQ answer: POST /api/study-plans/[id]/attempt with { questionId, userAnswer: correctAnswer, timeTaken: 5000 }. Verify isCorrect: true, proficiencyUpdate shows increase, DB ConceptNode has updated proficiency. Submit incorrect answer: verify proficiency decreases slightly.</manual>
  </verify>
  <done>POST /attempt returns correct isCorrect, proficiencyUpdate, sessionUpdate; ConceptNode in DB shows updated proficiency + nextDue; AttemptRecord created; zero TypeScript errors</done>
</task>

<task type="auto">
  <name>Task 2: GET + PATCH /session — get/create session and end session</name>
  <files>adaptive-tutor/src/app/api/study-plans/[id]/session/route.ts</files>
  <action>
    Create the session management route. This file needs a directory: create `src/app/api/study-plans/[id]/session/route.ts`.

    ```typescript
    // adaptive-tutor/src/app/api/study-plans/[id]/session/route.ts
    import { NextRequest, NextResponse } from "next/server";
    import { prisma } from "@/lib/prisma";

    /**
     * GET /api/study-plans/[id]/session
     * Returns the current active session for a study plan, or creates one if none exists.
     */
    export async function GET(
      _req: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      const { id } = await params;  // MUST await params (Next.js 16)

      const plan = await prisma.studyPlan.findUnique({ where: { id } });
      if (!plan) return NextResponse.json({ error: "Study plan not found" }, { status: 404 });

      // Get most recent active session or create one
      let session = await prisma.sessionRecord.findFirst({
        where: { studyPlanId: id, endTime: null },
        orderBy: { startTime: "desc" },
      });

      if (!session) {
        session = await prisma.sessionRecord.create({
          data: { studyPlanId: id, sessionType: "practice" },
        });
      }

      const accuracy = session.questionsAttempted > 0
        ? session.questionsCorrect / session.questionsAttempted
        : 0;

      return NextResponse.json({
        session: {
          ...session,
          accuracy,
          conceptsCovered: JSON.parse(session.conceptsCoveredJson || "[]"),
          startTime: session.startTime.toISOString(),
          endTime: session.endTime?.toISOString() ?? null,
        },
      });
    }

    /**
     * PATCH /api/study-plans/[id]/session
     * End a session by setting endTime = now.
     * Body: { sessionId: string }
     */
    export async function PATCH(
      req: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      const { id } = await params;  // MUST await params

      const body = await req.json().catch(() => ({}));
      const { sessionId } = body as { sessionId?: string };

      // Find session to end
      const session = sessionId
        ? await prisma.sessionRecord.findUnique({ where: { id: sessionId } })
        : await prisma.sessionRecord.findFirst({
            where: { studyPlanId: id, endTime: null },
            orderBy: { startTime: "desc" },
          });

      if (!session) {
        return NextResponse.json({ error: "No active session found" }, { status: 404 });
      }

      const ended = await prisma.sessionRecord.update({
        where: { id: session.id },
        data: { endTime: new Date() },
      });

      const accuracy = ended.questionsAttempted > 0
        ? ended.questionsCorrect / ended.questionsAttempted
        : 0;

      return NextResponse.json({
        session: {
          ...ended,
          accuracy,
          startTime: ended.startTime.toISOString(),
          endTime: ended.endTime?.toISOString() ?? null,
          message: `Session complete. You studied ${JSON.parse(ended.conceptsCoveredJson || "[]").length} concept(s).`,
        },
      });
    }
    ```

    Key notes:
    - `await params` at top — Next.js 16 requirement
    - GET auto-creates a session if none active (idempotent session start)
    - PATCH sets endTime — call this when user hits "End Session" or completes all questions
    - No POST /session/end endpoint needed — PATCH handles it (simpler)
    - Dates must be serialized to ISO string for JSON (Prisma returns Date objects)
    - conceptsCoveredJson parsed to array in response
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -10</automated>
    <manual>GET /api/study-plans/[id]/session returns a session object (creates one if none). PATCH /api/study-plans/[id]/session returns session with endTime set. Check DB: SessionRecord has endTime after PATCH call.</manual>
  </verify>
  <done>GET /session returns active or new session; PATCH /session sets endTime; both use await params; zero TypeScript errors</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` in adaptive-tutor/ — zero errors
2. POST /attempt with a correct MCQ answer: isCorrect: true, proficiencyUpdate.newProficiency > previousProficiency
3. POST /attempt with wrong answer: isCorrect: false, newProficiency <= previousProficiency
4. After POST /attempt, check DB: AttemptRecord exists, ConceptNode.nextDue is updated
5. GET /session returns session with questionsAttempted count
6. PATCH /session sets endTime on the record
</verification>

<success_criteria>
- attempt/route.ts uses Prisma $transaction for atomic AttemptRecord + ConceptNode + SessionRecord writes
- Imports updateSM2, getNextDueDate from sm2.ts and updateProficiencyFromAttempt from proficiency.ts
- free_response: neutral treatment in Phase 3 (answer recorded, proficiency unchanged)
- flashcard: boolean determined by "correct"/"got_it" vs "incorrect"/"missed_it" user answer string
- MCQ/fill_blank: case-insensitive trimmed string match
- session/route.ts: GET auto-creates session; PATCH ends it; dates serialized to ISO strings
- Zero TypeScript errors across both files
</success_criteria>

<output>
After completion, create `.planning/phases/03-adaptive-practice-engine/03-04-SUMMARY.md`
</output>
