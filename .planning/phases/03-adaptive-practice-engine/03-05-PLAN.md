---
phase: 03-adaptive-practice-engine
plan: "05"
type: execute
wave: 3
depends_on:
  - "03-03"
  - "03-04"
files_modified:
  - adaptive-tutor/src/app/(tabs)/learn/page.tsx
  - adaptive-tutor/src/components/FloatingChatButton.tsx
autonomous: true
requirements:
  - LEARN-01
  - LEARN-02
  - LEARN-03
  - LEARN-05

must_haves:
  truths:
    - "Learn tab shows a loading state (spinner + 'Generating questions...') when POST /generate-questions is in progress"
    - "MCQ: tapping any option auto-submits immediately — no separate Submit button"
    - "Flashcard: question on front, tap to flip to answer, then swipe right to mark correct (Got it!) or swipe left to mark incorrect (Missed it) using framer-motion drag gesture — swipe IS the submission mechanism, no separate buttons needed"
    - "Flashcard shows visual drag indicators: left side shows '← ✗' (red), right side shows '✓ →' (green), indicators fade in proportionally as card is dragged"
    - "Fill-blank: text input with explicit Submit button (disabled until input non-empty)"
    - "Free-response: textarea with live character counter (0/500); explicit Submit button records answer only"
    - "After each submission: inline feedback shown (correct/incorrect badge + explanation + proficiency delta)"
    - "Auto-advance to next question after 2.5 seconds OR user taps 'Next Question' immediately"
    - "Session summary screen shown when question list is exhausted: stats + next review schedule + navigation buttons"
    - "FloatingChatButton stub renders in bottom-right corner; clicking it shows a 'Coming in Phase 4' placeholder"
    - "CSS uses var(--accent), var(--success), var(--error), var(--bg-card), var(--border), var(--text-primary) — NOT Tailwind color utilities"
    - "Learn tab progresses through idle → generating → loading → practicing → feedback → complete states without blank or unresponsive screens"
    - "Questions fetched with limit=DEFAULT_SESSION_LENGTH (20) from config.ts, not hardcoded 50"
  artifacts:
    - path: "adaptive-tutor/src/app/(tabs)/learn/page.tsx"
      provides: "Complete Learn tab: loading, all 4 question types, feedback, summary, session state machine"
      min_lines: 200
    - path: "adaptive-tutor/src/components/FloatingChatButton.tsx"
      provides: "Floating chat button stub — UI only, no backend wiring"
      contains: "FloatingChatButton"
  key_links:
    - from: "adaptive-tutor/src/app/(tabs)/learn/page.tsx"
      to: "/api/study-plans/[id]/generate-questions"
      via: "POST on mount if no questions"
      pattern: "generate-questions"
    - from: "adaptive-tutor/src/app/(tabs)/learn/page.tsx"
      to: "/api/study-plans/[id]/questions"
      via: "GET ?due=1&limit=DEFAULT_SESSION_LENGTH after session creation"
      pattern: "questions\\?due=1"
    - from: "adaptive-tutor/src/app/(tabs)/learn/page.tsx"
      to: "/api/study-plans/[id]/attempt"
      via: "POST on each answer submission"
      pattern: "attempt"
    - from: "adaptive-tutor/src/app/(tabs)/learn/page.tsx"
      to: "adaptive-tutor/src/lib/store.ts"
      via: "useAppStore for updateConceptProficiency, advanceQuestion, setCurrentQuestions"
      pattern: "useAppStore"
    - from: "adaptive-tutor/src/app/(tabs)/learn/page.tsx"
      to: "framer-motion"
      via: "motion.div with drag='x' for flashcard swipe gesture"
      pattern: "motion\\.div|drag.*x|onDragEnd"
---

<objective>
Build the complete Learn tab UI: all 4 question card types, the session state machine, inline feedback, auto-advance, session summary, and the FloatingChatButton stub.

Purpose: This is the user-facing feature — the daily practice loop. It must implement every locked interaction decision from CONTEXT.md: MCQ tap-to-auto-submit, flashcard tap-to-flip then swipe-left/right, fill-blank explicit submit, free-response record-only. Every interaction has been precisely specified.
Output: learn/page.tsx (complete rewrite from stub) + FloatingChatButton.tsx stub.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@adaptive-tutor/phase3tech/PHASE3-UI-SPEC.md
@adaptive-tutor/phase3tech/PHASE3-TECHNICAL-SPEC.md
@adaptive-tutor/src/app/(tabs)/learn/page.tsx
@adaptive-tutor/src/lib/store.ts
@adaptive-tutor/src/lib/types.ts
@adaptive-tutor/src/app/(tabs)/graph/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1a: Learn tab state machine, MCQ, fill-blank, free-response, feedback, summary</name>
  <files>adaptive-tutor/src/app/(tabs)/learn/page.tsx</files>
  <action>
    Rewrite learn/page.tsx completely. This is a "use client" component. Task 1b will add the flashcard swipe section to this same file — leave a clear `{/* FLASHCARD — see Task 1b */}` comment placeholder where the flashcard card JSX goes within the question type switch/conditional rendering.

    Read DEFAULT_SESSION_LENGTH from adaptive-tutor/src/lib/config.ts. Use it in the questions fetch URL: `?due=1&limit=${DEFAULT_SESSION_LENGTH}`. Do NOT hardcode 50.

    **State machine phases:**
    - `idle` — no study plan active (show "Go to Chat" empty state)
    - `generating` — POST /generate-questions in progress (spinner + message)
    - `loading` — fetching session + questions (brief spinner)
    - `practicing` — showing questions (the main loop)
    - `feedback` — showing result after submission (auto-advance in 2.5s)
    - `complete` — all questions exhausted (session summary screen)

    **On mount (useEffect with activeStudyPlanId dep):**
    1. If no activeStudyPlanId → stay `idle`
    2. POST /api/study-plans/[id]/generate-questions
       - If response.alreadyGenerated or success: continue
       - Else show `generating` state while waiting
    3. GET /api/study-plans/[id]/session (auto-creates session)
    4. GET /api/study-plans/[id]/questions?due=1&limit=${DEFAULT_SESSION_LENGTH}
    5. If questions.length === 0 → show "No questions due — come back tomorrow!" (still in `complete` with a special message)
    6. Set currentQuestions in Zustand via setCurrentQuestions(questions)
    7. Set currentQuestionIndex to 0 via setCurrentQuestionIndex(0)
    8. Set local session state (sessionId, sessionStart time)
    9. Phase → `practicing`

    **Interaction rules (LOCKED — implement exactly):**

    MCQ:
    - Render question text + 4 options (correctAnswer shuffled into distractors array)
    - Shuffle options once on question load (use useMemo or useRef to lock shuffle)
    - Tapping ANY option auto-submits immediately — NO separate Submit button
    - POST /api/study-plans/[id]/attempt with { questionId, userAnswer: optionText, timeTaken }
    - Phase → `feedback`

    Flashcard:
    - Leave a placeholder comment: `{/* FLASHCARD CARD — implemented in Task 1b using framer-motion */}`
    - Import `{ motion } from "framer-motion"` at the top of the file (framer-motion is already installed)
    - The flashcard rendering will be added in Task 1b; ensure the component structure supports a `isFlipped` state and a `handleFlashcardSwipe(direction: "left" | "right")` function that posts the attempt

    Fill-blank:
    - Text input (single line, autofocus)
    - Submit button — disabled until input.trim().length > 0
    - On submit → POST attempt with userAnswer=input
    - Phase → `feedback`

    Free-response:
    - Textarea (4 rows, resize-y)
    - Live character counter below: "X / 500 characters"
    - maxLength={500} on textarea
    - Submit button — disabled until textarea.trim().length > 0
    - On submit → POST attempt with userAnswer=textarea value
    - Phase → `feedback`
    - Free response: answer is recorded only; feedback says "Answer recorded. Evaluation coming in Phase 4."

    **Feedback phase:**
    - Show badge: "✅ Correct!" (green, var(--success)) OR "❌ Not quite." (red, #ef4444)
    - Show correct answer highlighted (for MCQ/fill_blank: which option was right)
    - Show explanation text (question.explanation) — always shown for incorrect, shown for correct too
    - Show proficiency delta: "Variables updated to 35% ↑" or "↓" — read from POST /attempt response
    - Call updateConceptProficiency(conceptId, newProficiency, newConfidence) on Zustand store
    - Auto-advance after 2500ms using useRef(setTimeout) — cancel on unmount
    - "Next Question →" button for immediate advance
    - On advance: increment questionIndex; if questionIndex >= questions.length → phase `complete`
    - IMPORTANT: Incorrect answers do NOT re-queue in session — just advance to next question

    **Session complete screen:**
    - Show session stats: questionsAttempted, questionsCorrect, accuracy %, time elapsed, concepts covered count
    - Show next review: list up to 5 concepts with their nextDue dates (if available in store conceptNodes)
    - Three buttons: [View Graph] → router.push('/graph'), [New Session] → reset + restart, [Switch to Chat] → router.push('/chat')
    - Use router.push() for navigation — NOT setActiveTab (locked decision)

    **Progress bar:**
    - width = (currentQuestionIndex / questions.length) * 100 + "%"
    - Styled with backgroundColor: "var(--accent)"

    **Accuracy display:**
    - "X% (correct/attempted)" — update after each submission

    **General styling rules (LOCKED):**
    - CSS custom properties: var(--accent), var(--accent-soft), var(--success), var(--error), var(--bg-card), var(--bg-tertiary), var(--border), var(--text-primary), var(--text-secondary), var(--text-muted)
    - Do NOT use Tailwind color utilities like bg-green-500, text-red-400 — use style={{}} with CSS vars
    - Use Tailwind layout/spacing utilities (flex, gap, p-4, w-full) — just not color utilities

    **State to track locally (useState):**
    ```typescript
    const [phase, setPhase] = useState<"idle"|"generating"|"loading"|"practicing"|"feedback"|"complete">("idle");
    const [questions, setQuestions] = useState<Question[]>([]);
    const [questionIndex, setQuestionIndex] = useState(0);
    const [sessionId, setSessionId] = useState<string|null>(null);
    const [sessionStart, setSessionStart] = useState<Date>(new Date());
    const [isFlipped, setIsFlipped] = useState(false);
    const [textInput, setTextInput] = useState("");
    const [charCount, setCharCount] = useState(0);
    const [lastResult, setLastResult] = useState<AttemptResult|null>(null);
    const [sessionStats, setSessionStats] = useState({ attempted: 0, correct: 0 });
    const advanceTimerRef = useRef<ReturnType<typeof setTimeout>|null>(null);
    ```

    Reset isFlipped and textInput/charCount on each new question.

    Use `const { activeStudyPlanId, updateConceptProficiency } = useAppStore()` from Zustand.

    Check the existing graph/page.tsx and chat/page.tsx for the router pattern used: `const router = useRouter()` from 'next/navigation', then `router.push('/graph')`.

    Render `<FloatingChatButton />` at the bottom of the JSX (imported from "@/components/FloatingChatButton") — uses fixed positioning so it floats regardless of scroll.
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>
      1. Navigate to /learn with an active study plan
      2. Should show loading/generating state then first question
      3. MCQ: click any option — should auto-submit (no Submit button visible)
      4. Fill-blank: text input + Submit button (disabled until text entered)
      5. Free-response: textarea with character counter
      6. After submit: feedback shows inline, auto-advances after ~2.5s
    </manual>
  </verify>
  <done>MCQ, fill-blank, free-response question types render and submit correctly; state machine progresses idle→generating→loading→practicing→feedback; session complete screen appears with stats; CSS vars used for colors; zero TypeScript errors</done>
</task>

<task type="auto">
  <name>Task 1b: Flashcard swipe implementation with framer-motion</name>
  <files>adaptive-tutor/src/app/(tabs)/learn/page.tsx</files>
  <action>
    Update learn/page.tsx to replace the flashcard placeholder comment with a full framer-motion swipe implementation.

    framer-motion is already installed in the project. Import at the top of the file:
    ```typescript
    import { motion, type PanInfo } from "framer-motion";
    ```

    **Flashcard interaction flow (LOCKED per CONTEXT.md):**
    1. Card shows question text on front with "Tap to reveal" hint
    2. User taps the card → `isFlipped = true` → answer revealed on back
    3. After flip: user swipes the card left or right to submit
       - Swipe right (offset.x > 80) → correct (Got it!)
       - Swipe left (offset.x < -80) → incorrect (Missed it!)
    4. The swipe IS the submission — no separate "Got it!" / "Missed it!" buttons

    **Visual drag indicators (show while dragging, fade in proportionally):**
    - Left edge: `← ✗` in red (#ef4444) — fades in as card dragged left
    - Right edge: `✓ →` in green (var(--success)) — fades in as card dragged right
    - Use `dragX` motion value to drive opacity: `useMotionValue(0)` + `useTransform`

    **Implementation:**
    ```typescript
    // Add these at the component top level (alongside other state):
    const dragX = useMotionValue(0);
    const leftIndicatorOpacity = useTransform(dragX, [-150, -80, 0], [1, 0.5, 0]);
    const rightIndicatorOpacity = useTransform(dragX, [0, 80, 150], [0, 0.5, 1]);
    ```

    Import: `import { motion, useMotionValue, useTransform, type PanInfo } from "framer-motion";`

    **handleFlashcardSwipe function (called from onDragEnd):**
    ```typescript
    const handleFlashcardSwipe = async (direction: "left" | "right") => {
      const isCorrect = direction === "right";
      const userAnswer = isCorrect ? "got_it" : "missed_it";
      const timeTaken = Date.now() - questionStartTime; // track start time per question in a ref

      await submitAttempt(currentQuestion.id, userAnswer, timeTaken);
      // submitAttempt posts to /api/study-plans/[id]/attempt and sets phase → "feedback"
    };
    ```

    **Flashcard JSX (replace the placeholder comment):**
    ```tsx
    {currentQuestion.questionType === "flashcard" && (
      <div className="relative flex items-center justify-center" style={{ minHeight: 200 }}>
        {/* Left drag indicator */}
        <motion.div
          style={{ opacity: leftIndicatorOpacity }}
          className="absolute left-2 top-1/2 -translate-y-1/2 text-2xl font-bold pointer-events-none select-none"
          aria-hidden="true"
        >
          <span style={{ color: "#ef4444" }}>← ✗</span>
        </motion.div>

        {/* Right drag indicator */}
        <motion.div
          style={{ opacity: rightIndicatorOpacity }}
          className="absolute right-2 top-1/2 -translate-y-1/2 text-2xl font-bold pointer-events-none select-none"
          aria-hidden="true"
        >
          <span style={{ color: "var(--success)" }}>✓ →</span>
        </motion.div>

        {/* The draggable card */}
        <motion.div
          drag={isFlipped ? "x" : false}
          dragConstraints={{ left: -100, right: 100 }}
          dragElastic={0.2}
          style={{ x: dragX }}
          onDragEnd={(_event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
            if (info.offset.x > 80) {
              handleFlashcardSwipe("right"); // correct — Got it!
            } else if (info.offset.x < -80) {
              handleFlashcardSwipe("left"); // incorrect — Missed it!
            } else {
              // Snap back — not enough drag distance
              dragX.set(0);
            }
          }}
          onClick={() => {
            if (!isFlipped) setIsFlipped(true);
          }}
          className="w-full rounded-2xl p-6 cursor-pointer select-none"
          style={{
            backgroundColor: "var(--bg-card)",
            border: "1px solid var(--border)",
            minHeight: 160,
          }}
          whileTap={{ scale: 0.98 }}
        >
          {!isFlipped ? (
            <div className="flex flex-col items-center gap-3">
              <p className="text-center text-base" style={{ color: "var(--text-primary)" }}>
                {currentQuestion.questionText}
              </p>
              <p className="text-xs" style={{ color: "var(--text-muted)" }}>
                Tap to reveal answer
              </p>
            </div>
          ) : (
            <div className="flex flex-col items-center gap-3">
              <p className="text-center text-base font-semibold" style={{ color: "var(--text-primary)" }}>
                {currentQuestion.correctAnswer}
              </p>
              <p className="text-xs" style={{ color: "var(--text-muted)" }}>
                Swipe right if you knew it · Swipe left if you missed it
              </p>
            </div>
          )}
        </motion.div>
      </div>
    )}
    ```

    Key implementation notes:
    - `drag={isFlipped ? "x" : false}` — card is NOT draggable before flip; tap to flip, then swipe to submit
    - Reset `dragX.set(0)` and `isFlipped = false` when advancing to the next question
    - `dragConstraints={{ left: -100, right: 100 }}` limits physical drag range; `dragElastic={0.2}` adds slight bounce
    - Threshold: offset.x > 80 = right swipe (correct), offset.x < -80 = left swipe (incorrect)
    - If drag distance is insufficient (between -80 and +80), snap back: `dragX.set(0)` — do NOT submit
    - The attempt POST uses userAnswer="got_it" or "missed_it" (matches attempt route flashcard handling in 03-04)
    - Do NOT add separate "Got it!" / "Missed it!" buttons — the swipe IS the submission mechanism per CONTEXT.md locked decision
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>
      1. Navigate to /learn with an active study plan that has flashcard questions
      2. When flashcard appears: tap the card — it should flip to show the answer
      3. After flip: drag the card right (past 80px threshold) — should submit as correct and show feedback
      4. On a new flashcard: drag left past -80px — should submit as incorrect
      5. Drag less than 80px in either direction — card should snap back (no submission)
      6. While dragging: left side should show red "← ✗", right side shows green "✓ →" fading in proportionally
      7. NO separate "Got it!" / "Missed it!" buttons should be visible
    </manual>
  </verify>
  <done>Flashcard uses motion.div with drag="x"; swipe right >80px submits correct, swipe left <-80px submits incorrect; drag indicators fade in proportionally; insufficient drag snaps back; no button fallback; zero TypeScript errors</done>
</task>

<task type="auto">
  <name>Task 2: FloatingChatButton stub</name>
  <files>adaptive-tutor/src/components/FloatingChatButton.tsx</files>
  <action>
    Create FloatingChatButton.tsx as a UI stub — NO backend wiring (deferred to Phase 4).

    ```typescript
    // adaptive-tutor/src/components/FloatingChatButton.tsx
    "use client";

    import { useState } from "react";
    import { MessageCircle, X } from "lucide-react";

    /**
     * FloatingChatButton - UI stub for Phase 3.
     * Full chat backend integration deferred to Phase 4.
     * Shows a placeholder panel when clicked.
     */
    export function FloatingChatButton() {
      const [isOpen, setIsOpen] = useState(false);

      return (
        <>
          {/* Slide-up panel */}
          {isOpen && (
            <div
              className="fixed bottom-20 right-4 w-80 rounded-2xl border shadow-2xl p-4 z-50"
              style={{
                backgroundColor: "var(--bg-card)",
                borderColor: "var(--border)",
              }}
            >
              <div className="flex items-center justify-between mb-3">
                <span
                  className="text-sm font-semibold"
                  style={{ color: "var(--text-primary)" }}
                >
                  Ask your tutor
                </span>
                <button
                  onClick={() => setIsOpen(false)}
                  className="rounded-full p-1 hover:opacity-70 transition-opacity"
                  style={{ color: "var(--text-muted)" }}
                  aria-label="Close chat panel"
                >
                  <X size={16} />
                </button>
              </div>
              <p
                className="text-xs leading-relaxed"
                style={{ color: "var(--text-secondary)" }}
              >
                AI tutoring during practice sessions is coming in Phase 4.
              </p>
            </div>
          )}

          {/* Floating button */}
          <button
            onClick={() => setIsOpen((prev) => !prev)}
            className="fixed bottom-4 right-4 w-14 h-14 rounded-full flex items-center justify-center shadow-lg transition-transform hover:scale-105 active:scale-95 z-50"
            style={{
              backgroundColor: "var(--accent)",
              color: "#ffffff",
            }}
            aria-label="Open chat tutor"
          >
            <MessageCircle size={24} />
          </button>
        </>
      );
    }
    ```

    Import and render `<FloatingChatButton />` at the bottom of learn/page.tsx's JSX (inside the outermost div, after the main content area). It uses fixed positioning so it floats over the page regardless of scroll position.

    Use Lucide icons MessageCircle and X — these are already in the project (used by other components).

    Do NOT wire to any chat API. This is strictly UI affordance only (Phase 4 deferred decision, confirmed in CONTEXT.md deferred section).
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -10</automated>
    <manual>Navigate to /learn. A circular button should appear in the bottom-right corner. Clicking it shows a small "Coming in Phase 4" panel. Clicking X or the button again closes it. Button is always visible regardless of question type shown.</manual>
  </verify>
  <done>FloatingChatButton renders in bottom-right of Learn tab; click toggles stub panel; no backend calls made; zero TypeScript errors</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` in adaptive-tutor/ — zero errors
2. Learn tab loads with active study plan: generating → loading → first question displayed
3. MCQ: tap option → auto-submits, NO Submit button visible
4. Flashcard: tap card → flip → swipe right (>80px) = correct, swipe left (<-80px) = incorrect; no buttons shown; drag indicators visible
5. Fill-blank: text input + Submit button (disabled until typed)
6. Free-response: textarea, character counter updates live
7. Feedback shows inline after each answer, auto-advances in ~2.5s
8. After exhausting questions: summary screen with [View Graph] [New Session] [Switch to Chat]
9. FloatingChatButton visible in bottom-right, clicking shows "Coming in Phase 4" stub panel
10. No Tailwind color utilities used (only var(--...)) for colors
11. Questions fetched with limit=DEFAULT_SESSION_LENGTH (20) from config.ts
</verification>

<success_criteria>
- State machine progresses: idle → generating → loading → practicing → feedback → complete without blank screens
- MCQ auto-submits on option tap (no Submit button for MCQ)
- Flashcard: tap to flip, then framer-motion motion.div swipe gesture: right swipe >80px = correct, left swipe <-80px = incorrect, snap back if insufficient drag; visual indicators "← ✗" / "✓ →" fade in proportionally while dragging; NO separate buttons
- Fill-blank: Submit button explicit and disabled until input has text
- Free-response: textarea + character counter (0/500); Submit records only
- Feedback inline (not full-screen modal); auto-advance after 2.5s; "Next Question" for immediate advance
- Incorrect answers NOT re-queued (just move to next)
- Summary screen shows correct stats + router.push navigation
- FloatingChatButton stub present — no backend wiring
- All CSS colors via var(--...) custom properties
- Questions fetch uses DEFAULT_SESSION_LENGTH (20) not hardcoded 50
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-adaptive-practice-engine/03-05-SUMMARY.md`
</output>
