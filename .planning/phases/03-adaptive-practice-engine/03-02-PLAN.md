---
phase: 03-adaptive-practice-engine
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - adaptive-tutor/src/lib/algorithms/proficiency.ts
  - adaptive-tutor/src/lib/store.ts
  - adaptive-tutor/src/lib/prompts/questions.ts
autonomous: true
requirements:
  - LEARN-03
  - LEARN-04

must_haves:
  truths:
    - "updateProficiencyFromAttempt exists in proficiency.ts and returns {proficiency, confidence} per the PHASE3-TECHNICAL-SPEC.md rules"
    - "updateProficiencyFromAttempt exported from proficiency.ts with tier penalty (tier3 incorrect penalizes more than tier1) and confidence boost on correct answers"
    - "Zustand store has getCurrentQuestion(), advanceQuestion(), setCurrentSessionScore() helpers"
    - "generateQuestionsPrompt(concept) returns a prompt string requesting JSON array with all 4 question types"
    - "LLMQuestionSchema validates question JSON from MiniMax with Zod (type, text, answer, distractors, explanation, difficulty)"
  artifacts:
    - path: "adaptive-tutor/src/lib/algorithms/proficiency.ts"
      provides: "updateProficiencyFromAttempt function added alongside existing inferInitialProficiency"
      exports: ["inferInitialProficiency", "updateProficiencyFromAttempt"]
    - path: "adaptive-tutor/src/lib/store.ts"
      provides: "Extended Zustand store with session score and question navigation helpers"
      contains: "getCurrentQuestion|advanceQuestion|setCurrentSessionScore"
    - path: "adaptive-tutor/src/lib/prompts/questions.ts"
      provides: "Question generation prompt + LLM response Zod schema"
      exports: ["generateQuestionsPrompt", "LLMQuestionSchema"]
  key_links:
    - from: "adaptive-tutor/src/lib/prompts/questions.ts"
      to: "adaptive-tutor/src/app/api/study-plans/[id]/generate-questions/route.ts"
      via: "imported in generate-questions endpoint (Plan 03-03)"
      pattern: "generateQuestionsPrompt|LLMQuestionSchema"
    - from: "adaptive-tutor/src/lib/algorithms/proficiency.ts"
      to: "adaptive-tutor/src/app/api/study-plans/[id]/attempt/route.ts"
      via: "imported updateProficiencyFromAttempt in attempt route (Plan 03-04)"
      pattern: "updateProficiencyFromAttempt"
---

<objective>
Add the proficiency update function, Zustand store session helpers, and question generation prompt/schema needed by the API layer.

Purpose: These three files form the shared library layer that both the API endpoints (03-03, 03-04) and the UI (03-05) depend on. Building them first in Wave 1 allows Plans 03-03 and 03-04 to run in parallel in Wave 2.
Output: Extended proficiency.ts, extended store.ts, new prompts/questions.ts with Zod schema.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@adaptive-tutor/phase3tech/PHASE3-TECHNICAL-SPEC.md
@adaptive-tutor/src/lib/algorithms/proficiency.ts
@adaptive-tutor/src/lib/store.ts
@adaptive-tutor/src/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add updateProficiencyFromAttempt to proficiency.ts</name>
  <files>adaptive-tutor/src/lib/algorithms/proficiency.ts</files>
  <action>
    Keep existing inferInitialProficiency function unchanged. Add the following new export at the bottom of the file:

    ```typescript
    export function updateProficiencyFromAttempt(
      currentProficiency: number,
      confidence: number,
      isCorrect: boolean,
      difficultyTier: 1 | 2 | 3
    ): { proficiency: number; confidence: number } {
      let newProf = currentProficiency;
      let newConf = confidence;

      const baseGain = 0.05;
      const tierPenalty = ({ 1: 0, 2: 0.02, 3: 0.04 } as const)[difficultyTier];
      const confBoost = 0.1;

      if (isCorrect) {
        const boost = baseGain + (confidence * confBoost);
        newProf = Math.min(1.0, currentProficiency + boost);
        newConf = Math.min(1.0, confidence + 0.05);
      } else {
        newProf = Math.max(0.0, currentProficiency + 0.01 - tierPenalty);
        newConf = Math.max(0.0, confidence - 0.1);
      }

      return { proficiency: newProf, confidence: newConf };
    }
    ```

    This is verbatim from PHASE3-TECHNICAL-SPEC.md. Do not alter the formula.
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Confirm updateProficiencyFromAttempt is exported and tier 3 incorrect gives larger penalty than tier 1 incorrect</manual>
  </verify>
  <done>proficiency.ts compiles cleanly and exports both inferInitialProficiency and updateProficiencyFromAttempt</done>
</task>

<task type="auto">
  <name>Task 2: Extend Zustand store with session score and question navigation</name>
  <files>adaptive-tutor/src/lib/store.ts</files>
  <action>
    Read the current store.ts carefully. Add the following to the AppState interface and implementation:

    **Add to interface:**
    ```typescript
    currentSessionScore: number;           // running accuracy 0.0-1.0
    setCurrentSessionScore: (score: number) => void;
    getCurrentQuestion: () => Question | null;
    advanceQuestion: () => void;
    ```

    **Add to initial state:**
    ```typescript
    currentSessionScore: 0,
    ```

    **Add implementations (in the create() call):**
    ```typescript
    setCurrentSessionScore: (score) => set({ currentSessionScore: score }),

    getCurrentQuestion: () => {
      const state = store.getState();  // use store.getState() — NOT closure, avoids stale state
      const { currentQuestions, currentQuestionIndex } = state;
      return currentQuestions[currentQuestionIndex] ?? null;
    },

    advanceQuestion: () => {
      const state = store.getState();  // use store.getState()
      const nextIndex = state.currentQuestionIndex + 1;
      set({ currentQuestionIndex: nextIndex });
    },
    ```

    IMPORTANT: The store variable is assigned the result of create(...). You need to assign it so getCurrentQuestion and advanceQuestion can call store.getState(). Pattern:
    ```typescript
    const store = create<AppState>((set) => ({
      ...
    }));
    export const useAppStore = store;
    ```
    (or export the store reference as-is — check how the current file exports it and maintain that pattern)

    Do NOT modify existing actions (setCurrentSession, setCurrentQuestions, setCurrentQuestionIndex, updateConceptProficiency, loadStudyPlanData, etc.).
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Confirm store exports getCurrentQuestion, advanceQuestion, setCurrentSessionScore without breaking existing exports</manual>
  </verify>
  <done>store.ts compiles cleanly with new session helpers; existing state and actions unchanged</done>
</task>

<task type="auto">
  <name>Task 3: Create question generation prompt and Zod schema</name>
  <files>adaptive-tutor/src/lib/prompts/questions.ts</files>
  <action>
    Create a new file at adaptive-tutor/src/lib/prompts/questions.ts:

    ```typescript
    import { z } from "zod";
    import type { ConceptNode } from "@/lib/types";

    /**
     * Generate practice questions prompt for a single concept.
     * Asks MiniMax for a JSON array of 5 questions covering all 4 types.
     * Difficulty is set by concept tier: tier1=0.3, tier2=0.6, tier3=0.8
     */
    export function generateQuestionsPrompt(concept: ConceptNode): string {
      const tierDifficulty = { 1: 0.3, 2: 0.6, 3: 0.8 }[concept.difficultyTier] ?? 0.5;
      const keyTerms = (() => {
        try { return JSON.parse(concept.keyTermsJson).join(", "); } catch { return ""; }
      })();

      return `Generate exactly 5 diverse practice questions for this learning concept.

Concept: ${concept.name}
Description: ${concept.description}
Key Terms: ${keyTerms || "N/A"}
Difficulty Tier: ${concept.difficultyTier} (1=foundational, 2=intermediate, 3=advanced)

Return a JSON array with no markdown fences, no extra text. Each object must include:
{
  "questionType": "mcq" | "fill_blank" | "flashcard" | "free_response",
  "questionText": "...",
  "correctAnswer": "...",
  "distractors": ["...", "...", "..."],   // exactly 3 for MCQ; empty array for other types
  "explanation": "...",
  "difficulty": ${tierDifficulty}
}

Rules:
- Include exactly 1 question of each type: mcq, fill_blank, flashcard, free_response (5th can be any type)
- MCQ distractors: plausible wrong answers (not obviously false)
- fill_blank: questionText has a ___ blank; correctAnswer fills the blank
- flashcard: questionText is the front of the card; correctAnswer is the back
- free_response: open-ended, no single correct answer; correctAnswer is a model answer
- Do not output markdown code blocks or any text outside the JSON array
- difficulty must be a float between 0.0 and 1.0`;
    }

    /**
     * Zod schema for validating a single LLM-generated question.
     */
    export const LLMQuestionItemSchema = z.object({
      questionType: z.enum(["mcq", "fill_blank", "flashcard", "free_response"]),
      questionText: z.string().min(5),
      correctAnswer: z.string().min(1),
      distractors: z.array(z.string()).default([]),
      explanation: z.string().default(""),
      difficulty: z.number().min(0).max(1).default(0.5),
    });

    export const LLMQuestionSchema = z.array(LLMQuestionItemSchema).min(1);

    export type LLMQuestionItem = z.infer<typeof LLMQuestionItemSchema>;
    ```

    Import z from "zod" — this package is already in the project (used by schemas.ts).
    Check adaptive-tutor/src/lib/schemas.ts for the parseLLMJson utility to understand how MiniMax output is parsed elsewhere — the generate-questions endpoint (Plan 03-03) will use parseLLMJson from schemas.ts followed by LLMQuestionSchema.safeParse().
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Confirm the prompt instructs MiniMax to return 5 questions with all 4 types, no markdown fences, difficulty matches tier</manual>
  </verify>
  <done>prompts/questions.ts compiles cleanly; exports generateQuestionsPrompt, LLMQuestionSchema, LLMQuestionItemSchema, LLMQuestionItem type</done>
</task>

</tasks>

<verification>
Run `cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit` — zero type errors.
Confirm three files exist: proficiency.ts (extended), store.ts (extended), prompts/questions.ts (new).
</verification>

<success_criteria>
- updateProficiencyFromAttempt exported from proficiency.ts, formula matches PHASE3-TECHNICAL-SPEC.md
- Zustand store has getCurrentQuestion() using store.getState() (not stale closure), advanceQuestion(), setCurrentSessionScore()
- generateQuestionsPrompt returns a string with concept name, tier difficulty (0.3/0.6/0.8), instructions for all 4 question types, no markdown fence instruction
- LLMQuestionSchema is a Zod array schema that validates the expected MiniMax JSON output
- Zero TypeScript errors across all three files
</success_criteria>

<output>
After completion, create `.planning/phases/03-adaptive-practice-engine/03-02-SUMMARY.md`
</output>
