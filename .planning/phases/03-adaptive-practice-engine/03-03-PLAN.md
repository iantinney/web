---
phase: 03-adaptive-practice-engine
plan: "03"
type: execute
wave: 2
depends_on:
  - "03-02"
files_modified:
  - adaptive-tutor/src/app/api/study-plans/[id]/generate-questions/route.ts
  - adaptive-tutor/src/app/api/study-plans/[id]/questions/route.ts
autonomous: true
requirements:
  - LEARN-04

must_haves:
  truths:
    - "POST /api/study-plans/[id]/generate-questions generates 3-5 questions per concept when none exist and returns { questionCount, conceptsCovered }"
    - "Calling generate-questions twice does NOT create duplicate questions (idempotent)"
    - "GET /api/study-plans/[id]/questions?due=1&limit=20 returns questions sorted by the session selector logic: prereq overdue first, then MCQ before fill-blank/flashcard, then free-response; per-concept cap of 2-3 applied"
    - "Question selector logic encodes: proficiency < 0.4 → prefer MCQ/flashcard (difficulty <= 0.5); growing proficiency → include all types"
    - "Questions are stored in the Question table linked to the correct conceptNodeId"
    - "MiniMax failures on individual concepts are logged and skipped, not fatal to the whole generation"
  artifacts:
    - path: "adaptive-tutor/src/app/api/study-plans/[id]/generate-questions/route.ts"
      provides: "POST endpoint: idempotent per-concept question generation via MiniMax"
      exports: ["POST"]
    - path: "adaptive-tutor/src/app/api/study-plans/[id]/questions/route.ts"
      provides: "GET endpoint: session question selector with SM-2 due filtering, prereq priority, type ease-in order, per-concept cap"
      exports: ["GET"]
  key_links:
    - from: "adaptive-tutor/src/app/api/study-plans/[id]/generate-questions/route.ts"
      to: "prisma.question"
      via: "prisma.question.createMany inside loop per concept"
      pattern: "prisma\\.question\\.(create|createMany)"
    - from: "adaptive-tutor/src/app/api/study-plans/[id]/questions/route.ts"
      to: "adaptive-tutor/src/app/(tabs)/learn/page.tsx"
      via: "fetched in learn page on session start with GET /questions?due=1&limit=DEFAULT_SESSION_LENGTH"
      pattern: "questions\\?due=1"
---

<objective>
Build two endpoints: the idempotent question generation endpoint (calls MiniMax once per concept, cached forever) and the smart question GET endpoint (applies session selector logic per user decisions).

Purpose: These are the backend foundation for the Learn tab. The generate-questions endpoint is the "production pipeline" that transforms the concept graph into a question bank. The questions GET endpoint is the "runtime query" that applies all the session composition rules locked in CONTEXT.md.
Output: Two new route.ts files under /api/study-plans/[id]/.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@adaptive-tutor/phase3tech/PHASE3-API-SPEC.md
@adaptive-tutor/phase3tech/PHASE3-TECHNICAL-SPEC.md
@adaptive-tutor/src/lib/prompts/questions.ts
@adaptive-tutor/src/app/api/study-plans/[id]/generate-graph/route.ts
@adaptive-tutor/src/lib/schemas.ts
@adaptive-tutor/src/lib/minimax-native.ts
@adaptive-tutor/src/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: POST /generate-questions — idempotent MiniMax per-concept generation</name>
  <files>adaptive-tutor/src/app/api/study-plans/[id]/generate-questions/route.ts</files>
  <action>
    Create the generate-questions POST endpoint. Follow the exact same MiniMax + parseLLMJson + Zod pattern used in generate-graph/route.ts.

    ```typescript
    // adaptive-tutor/src/app/api/study-plans/[id]/generate-questions/route.ts
    import { NextRequest, NextResponse } from "next/server";
    import { prisma } from "@/lib/prisma";
    import { generateText } from "@/lib/minimax-native";
    import { parseLLMJson } from "@/lib/schemas";
    import { generateQuestionsPrompt, LLMQuestionSchema } from "@/lib/prompts/questions";

    export async function POST(
      _req: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      const { id } = await params;  // MUST await params (Next.js 16)

      // 1. Verify study plan exists
      const plan = await prisma.studyPlan.findUnique({
        where: { id },
        include: { concepts: true },
      });
      if (!plan) return NextResponse.json({ error: "Study plan not found" }, { status: 404 });
      if (plan.concepts.length === 0) {
        return NextResponse.json({ error: "No concepts in study plan" }, { status: 400 });
      }

      // 2. Check idempotency: if ANY questions already exist, return early
      const existingCount = await prisma.question.count({
        where: { conceptNode: { studyPlanId: id } },
      });
      if (existingCount > 0) {
        const conceptsCovered = [...new Set(
          (await prisma.question.findMany({
            where: { conceptNode: { studyPlanId: id } },
            select: { conceptNodeId: true },
          })).map(q => q.conceptNodeId)
        )];
        return NextResponse.json({
          questionCount: existingCount,
          conceptsCovered,
          message: "Questions already exist for this study plan",
          alreadyGenerated: true,
        });
      }

      // 3. Generate questions per concept
      const conceptsCovered: string[] = [];
      let totalGenerated = 0;
      const failedConcepts: string[] = [];

      for (const concept of plan.concepts) {
        if (concept.isDeprecated) continue;

        try {
          // Build prompt
          const prompt = generateQuestionsPrompt(concept);

          // Call MiniMax (temperature 0.3, retry at 0.1 on JSON failure — matching generate-graph pattern)
          let rawText: string;
          try {
            rawText = await generateText(
              [{ role: "user", content: "Generate the practice questions JSON array." }],
              prompt,
              { temperature: 0.3, maxTokens: 2048, model: "MiniMax-M2" }
            );
          } catch {
            // Retry at lower temperature
            rawText = await generateText(
              [{ role: "user", content: "Generate the practice questions JSON array." }],
              prompt,
              { temperature: 0.1, maxTokens: 2048, model: "MiniMax-M2" }
            );
          }

          // Parse + validate
          const parsed = parseLLMJson(rawText);
          const validated = LLMQuestionSchema.safeParse(parsed);
          if (!validated.success) {
            console.error(`[generate-questions] Validation failed for concept ${concept.id}:`, validated.error.message);
            failedConcepts.push(concept.id);
            continue;
          }

          // Insert into DB (createMany for batch efficiency)
          await prisma.question.createMany({
            data: validated.data.map(q => ({
              conceptNodeId: concept.id,
              questionType: q.questionType,
              questionText: q.questionText,
              correctAnswer: q.correctAnswer,
              distractorsJson: JSON.stringify(q.distractors),
              explanation: q.explanation,
              difficulty: q.difficulty,
            })),
          });

          conceptsCovered.push(concept.id);
          totalGenerated += validated.data.length;
        } catch (err) {
          console.error(`[generate-questions] Failed for concept ${concept.id}:`, err);
          failedConcepts.push(concept.id);
          // Continue to next concept — partial generation is acceptable
        }
      }

      return NextResponse.json({
        questionCount: totalGenerated,
        conceptsCovered,
        message: `Generated ${totalGenerated} questions across ${conceptsCovered.length} concepts`,
        ...(failedConcepts.length > 0 && { conceptsThatFailed: failedConcepts }),
      });
    }
    ```

    Key implementation notes:
    - `await params` at top — Next.js 16 requirement
    - Idempotency check: count existing questions for the study plan's concepts; if > 0, return early with alreadyGenerated: true
    - Loop over concepts, skip isDeprecated=true
    - parseLLMJson strips markdown fences (from schemas.ts — check how it's used in generate-graph)
    - LLMQuestionSchema.safeParse validates the array
    - prisma.question.createMany for each concept's questions
    - Continue on per-concept failure (log + add to failedConcepts) — don't fail the whole request
  </action>
  <verify>
    <automated>curl -s -X POST http://localhost:3000/api/study-plans/$(cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx ts-node -e "const {prisma} = require('./src/lib/prisma'); prisma.studyPlan.findFirst().then(p => { console.log(p?.id); process.exit(0); })" 2>/dev/null || echo "PLAN_ID")/generate-questions 2>&1 | head -5; echo "---"; cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -10</automated>
    <manual>Start dev server (npm run dev in adaptive-tutor/), visit http://localhost:3000, create a study plan via chat, then POST to /api/study-plans/[id]/generate-questions. Verify questionCount > 0. Call again — verify alreadyGenerated: true and same questionCount.</manual>
  </verify>
  <done>POST /generate-questions returns 200 with questionCount > 0 on first call; returns alreadyGenerated: true on second call; zero TypeScript errors</done>
</task>

<task type="auto">
  <name>Task 2: GET /questions — session selector with SM-2 priority, prereq weighting, type ease-in order</name>
  <files>adaptive-tutor/src/app/api/study-plans/[id]/questions/route.ts</files>
  <action>
    Create the questions GET endpoint that implements the full session composition logic from CONTEXT.md.

    Read DEFAULT_SESSION_LENGTH from adaptive-tutor/src/lib/config.ts (or wherever app config constants live) and use it as the default limit. Do NOT hardcode 50 — the config value is 20. If config.ts does not exist yet, use 20 as the default (matching the spec).

    Query params: `?due=1&limit=N` (due=1 means filter to SM-2 due or new concepts; limit defaults to DEFAULT_SESSION_LENGTH from config)

    Session composition rules (LOCKED DECISIONS — implement exactly):
    1. **SM-2 due filter:** Include concepts where nextDue <= now OR nextDue is null (never practiced)
    2. **Prereq priority:** Concepts that are prerequisites for other concepts get boosted priority when overdue. Score: prereqBoost = isPrereq ? 2.0 : 1.0, then multiply by overduenesss (how many days past due)
    3. **Per-concept cap:** Select at most 2-3 questions per concept per session
    4. **Question type ease-in order:** Within each concept's selected questions, order: MCQ first → flashcard/fill_blank → free_response
    5. **Difficulty-to-proficiency matching:** proficiency < 0.4 → prefer MCQ and flashcard (difficulty <= 0.5); proficiency >= 0.4 → include all types. Use the `difficulty` field on Question for filtering.
    6. **Incorrect answers do NOT re-queue:** This is handled at the UI level, not this endpoint — the endpoint just returns the ordered question list

    ```typescript
    // adaptive-tutor/src/app/api/study-plans/[id]/questions/route.ts
    import { NextRequest, NextResponse } from "next/server";
    import { prisma } from "@/lib/prisma";

    const TYPE_ORDER: Record<string, number> = {
      mcq: 0,
      flashcard: 1,
      fill_blank: 2,
      free_response: 3,
    };

    const PER_CONCEPT_CAP = 3; // 2-3 per CONTEXT.md — use 3 as default
    const DEFAULT_LIMIT = 20; // matches DEFAULT_SESSION_LENGTH from config.ts

    export async function GET(
      req: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      const { id } = await params;  // MUST await params
      const { searchParams } = new URL(req.url);
      const dueOnly = searchParams.get("due") === "1";
      const limit = Math.min(parseInt(searchParams.get("limit") ?? String(DEFAULT_LIMIT), 10), 100);

      // 1. Get study plan with concepts and edges
      const plan = await prisma.studyPlan.findUnique({
        where: { id },
        include: {
          concepts: true,
          edges: true,
        },
      });
      if (!plan) return NextResponse.json({ error: "Study plan not found" }, { status: 404 });

      const now = new Date();

      // 2. Identify which conceptIds are prerequisites for others (appear as fromNodeId)
      const prereqConceptIds = new Set(plan.edges.map(e => e.fromNodeId));

      // 3. Filter concepts: due or new (nextDue <= now OR nextDue null), not deprecated, proficiency < 1.0
      const dueConcepts = plan.concepts.filter(c => {
        if (c.isDeprecated) return false;
        if (c.proficiency >= 1.0) return false; // mastered
        if (!dueOnly) return true;
        if (!c.nextDue) return true; // never practiced = always due
        return new Date(c.nextDue) <= now;
      });

      if (dueConcepts.length === 0) {
        return NextResponse.json({
          questions: [],
          metadata: { total: 0, dueConceptCount: 0, message: "All concepts mastered or not yet due" },
        });
      }

      // 4. Score concepts: prereqs overdue get highest priority
      const scoredConcepts = dueConcepts.map(c => {
        const isPrereq = prereqConceptIds.has(c.id);
        let overdueDays = 0;
        if (c.nextDue) {
          overdueDays = Math.max(0, (now.getTime() - new Date(c.nextDue).getTime()) / 86400000);
        }
        const score = (isPrereq ? 2.0 : 1.0) * (1 + overdueDays);
        return { concept: c, score, isPrereq };
      }).sort((a, b) => b.score - a.score);

      // 5. For each concept (in priority order), select 2-3 questions
      //    applying difficulty filter based on proficiency, then sort by type ease-in order
      const selectedQuestions: Array<{
        id: string; conceptNodeId: string; conceptName: string;
        questionType: string; questionText: string; correctAnswer: string;
        distractorsJson: string; explanation: string; difficulty: number;
      }> = [];

      for (const { concept } of scoredConcepts) {
        if (selectedQuestions.length >= limit) break;

        // Get all questions for this concept
        const conceptQuestions = await prisma.question.findMany({
          where: { conceptNodeId: concept.id },
        });

        if (conceptQuestions.length === 0) continue;

        // Filter by difficulty-to-proficiency match
        const proficiency = concept.proficiency;
        const filtered = conceptQuestions.filter(q => {
          if (proficiency < 0.4) {
            // Low proficiency: prefer easy question types (MCQ, flashcard)
            // difficulty <= 0.5 OR type is mcq/flashcard
            return q.difficulty <= 0.5 || q.questionType === "mcq" || q.questionType === "flashcard";
          }
          return true; // higher proficiency: allow all types
        });

        const pool = filtered.length > 0 ? filtered : conceptQuestions; // fallback to all if filter yields nothing

        // Sort by type ease-in order
        const sorted = [...pool].sort((a, b) =>
          (TYPE_ORDER[a.questionType] ?? 99) - (TYPE_ORDER[b.questionType] ?? 99)
        );

        // Apply per-concept cap
        const capped = sorted.slice(0, PER_CONCEPT_CAP);

        selectedQuestions.push(...capped.map(q => ({
          ...q,
          conceptName: concept.name,
          createdAt: q.createdAt.toISOString(),
        })));
      }

      return NextResponse.json({
        questions: selectedQuestions.slice(0, limit),
        metadata: {
          total: selectedQuestions.length,
          dueConceptCount: dueConcepts.length,
        },
      });
    }
    ```

    Key notes:
    - `await params` at top — Next.js 16 requirement
    - Default limit = DEFAULT_SESSION_LENGTH (20), NOT 50
    - Prereq priority: fromNodeId edges = prereq concepts, get 2x score multiplier
    - Difficulty filter: proficiency < 0.4 → filter to difficulty <= 0.5 OR type MCQ/flashcard
    - Type order: MCQ=0, flashcard=1, fill_blank=2, free_response=3
    - Per-concept cap = 3 (covers the 2-3 range from CONTEXT.md)
    - Incorrect answers NOT re-queued: handled by UI (Plan 03-05), not this endpoint
  </action>
  <verify>
    <automated>cd /Users/rykkim/Documents/githublocal/yale-agentic-ai-hackathon/adaptive-tutor && npx tsc --noEmit 2>&1 | head -10</automated>
    <manual>After generating questions (Task 1), call GET /api/study-plans/[id]/questions?due=1&limit=20. Verify: JSON has questions array, each entry has conceptName, questionType, questionText. Check that MCQ questions appear before free_response for the same concept.</manual>
  </verify>
  <done>GET /questions returns ordered question list; TypeScript compiles cleanly; prereq concepts sorted higher; MCQ before free_response; default limit is 20</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` in adaptive-tutor/ — zero errors
2. POST /generate-questions on a plan with concepts returns questionCount > 0
3. Second POST returns alreadyGenerated: true with same count
4. GET /questions?due=1&limit=20 returns questions sorted MCQ before fill_blank before free_response
</verification>

<success_criteria>
- generate-questions POST: idempotent, persists to DB, handles per-concept MiniMax failures gracefully
- questions GET: applies SM-2 due filter, prereq priority, difficulty-to-proficiency match (proficiency < 0.4 → MCQ/flashcard preferred), type ease-in order, per-concept cap of 3
- Default session limit = 20 (DEFAULT_SESSION_LENGTH from config.ts), not hardcoded 50
- Both routes use `await params` (Next.js 16 pattern)
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-adaptive-practice-engine/03-03-SUMMARY.md`
</output>
