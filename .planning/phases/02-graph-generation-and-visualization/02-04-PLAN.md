---
phase: "02"
plan: "02-04"
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - "adaptive-tutor/src/app/(tabs)/graph/page.tsx"
  - "adaptive-tutor/src/lib/store.ts"
  - "adaptive-tutor/src/app/api/study-plans/[id]/generate-graph/route.ts"
autonomous: true
must_haves:
  truths:
    - "Initial proficiency is inferred from user's stated prior knowledge during graph generation"
    - "Graph nodes show colored proficiency (not all gray) when prior knowledge is stated"
    - "Graph proficiency colors update live when concept proficiency changes in the Zustand store"
    - "Lesson plan notification displays after graph generation"
  artifacts:
    - path: "adaptive-tutor/src/app/api/study-plans/[id]/generate-graph/route.ts"
      provides: "Initial proficiency inference based on prior knowledge"
      contains: "inferInitialProficiency"
    - path: "adaptive-tutor/src/lib/store.ts"
      provides: "Data loading action for hydrating store from API"
      contains: "loadStudyPlanData"
  key_links:
    - from: "generate-graph/route.ts"
      to: "ConceptNode DB records"
      via: "proficiency and confidence set during creation based on prior knowledge"
      pattern: "proficiency.*inferInitialProficiency"
    - from: "store.ts updateConceptProficiency"
      to: "graph/page.tsx flowNodes useMemo"
      via: "Zustand state change triggers recompute of React Flow nodes"
      pattern: "conceptNodes.*proficiency"
---

# Phase 02-04: Initial Proficiency Inference & Live Graph Updates

## Objective

Implement initial proficiency inference from user's stated prior knowledge during graph generation, add a data loading action to hydrate the Zustand store from the API, ensure proficiency color updates propagate live to the graph, and add a lesson plan notification after graph creation.

Purpose: Without proficiency inference, all nodes start gray (untested). Inferring initial proficiency from prior knowledge gives users immediate visual feedback. Live updates ensure the graph reflects practice results in real time. The lesson plan notification (GRAPH-05) confirms to users what was generated.

Output: Graph nodes start with meaningful colors based on stated knowledge, update live during practice, and a lesson plan summary is shown after generation.

## Success Criteria

- [ ] `inferInitialProficiency(priorKnowledge, conceptName, difficultyTier)` function exists and returns proficiency 0-1
- [ ] During graph generation, if `priorKnowledge` is provided in the request body, initial proficiency and confidence are set per concept
- [ ] Novice prior knowledge: proficiency ~0.1-0.2, confidence 0.2
- [ ] Intermediate prior knowledge: proficiency ~0.3-0.5, confidence 0.25 (adjusted by tier)
- [ ] Expert prior knowledge: proficiency ~0.6-0.75, confidence 0.3 (adjusted by tier)
- [ ] No stated prior knowledge: proficiency 0.0, confidence 0.0 (gray/untested)
- [ ] `loadStudyPlanData(planId)` action in Zustand fetches `GET /api/study-plans/[id]` and populates `conceptNodes`, `conceptEdges`, `activeStudyPlanId`
- [ ] Graph proficiency colors update reactively when `updateConceptProficiency` is called (already wired via useMemo + useEffect, verify no regression)
- [ ] After graph generation, a lesson plan summary is shown: concept count, difficulty distribution, and list of concept names grouped by tier

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-graph-generation-and-visualization/02-RESEARCH.md
@.planning/phases/02-graph-generation-and-visualization/02-01-SUMMARY.md
@adaptive-tutor/src/app/api/study-plans/[id]/generate-graph/route.ts
@adaptive-tutor/src/lib/store.ts
@adaptive-tutor/src/lib/utils.ts
@adaptive-tutor/src/lib/config.ts
@adaptive-tutor/src/app/(tabs)/graph/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initial proficiency inference in graph generation endpoint</name>
  <files>
    adaptive-tutor/src/app/api/study-plans/[id]/generate-graph/route.ts
  </files>
  <action>
  1. Add `inferInitialProficiency` function to the route file (or a new utility file at `src/lib/algorithms/proficiencyInference.ts` if preferred -- keep it simple, inline in route is fine for hackathon):

     ```typescript
     function inferInitialProficiency(
       priorKnowledge: string,
       conceptName: string,
       difficultyTier: 1 | 2 | 3
     ): { proficiency: number; confidence: number } {
       if (!priorKnowledge || priorKnowledge.trim().length === 0) {
         return { proficiency: 0, confidence: 0 }; // untested/gray
       }

       const lower = priorKnowledge.toLowerCase();

       // Detect self-described level
       const isExpert = lower.includes("expert") || lower.includes("phd") ||
                        lower.includes("years of experience") || lower.includes("professional");
       const isIntermediate = lower.includes("some") || lower.includes("familiar") ||
                              lower.includes("worked with") || lower.includes("took a course") ||
                              lower.includes("basic understanding");

       // Base proficiency by level
       const baseProficiency = isExpert ? 0.7 : isIntermediate ? 0.4 : 0.15;
       const baseConfidence = isExpert ? 0.3 : isIntermediate ? 0.25 : 0.2;

       // Adjust down for higher difficulty tier concepts
       const tierPenalty = (difficultyTier - 1) * 0.15;

       return {
         proficiency: Math.max(0, Math.min(1, baseProficiency - tierPenalty)),
         confidence: baseConfidence,
       };
     }
     ```

  2. Update the `POST` handler to accept `priorKnowledge` from the request body:
     - Parse request body: `const body = await _req.json().catch(() => ({}));`
     - Extract `priorKnowledge`: `const priorKnowledge = (body as { priorKnowledge?: string }).priorKnowledge ?? ""`
     - Change function signature to accept request body (the `_req` is already available, just wasn't being read)

  3. When creating ConceptNode records in the loop, replace the hardcoded `proficiency: 0, confidence: 0` with:
     ```typescript
     const { proficiency: initProf, confidence: initConf } = inferInitialProficiency(
       priorKnowledge,
       concept.name,
       concept.difficultyTier as 1 | 2 | 3
     );
     // Use initProf and initConf instead of 0, 0
     ```

  4. Add a `lessonPlan` section to the API response:
     ```typescript
     const lessonPlan = {
       totalConcepts: createdNodes.length,
       tier1: graphData.concepts.filter(c => c.difficultyTier === 1).map(c => c.name),
       tier2: graphData.concepts.filter(c => c.difficultyTier === 2).map(c => c.name),
       tier3: graphData.concepts.filter(c => c.difficultyTier === 3).map(c => c.name),
     };
     ```
     Include `lessonPlan` in the response JSON alongside nodes, edges, nodeCount, edgeCount, removedEdges.
  </action>
  <verify>
  - `npx tsc --noEmit` passes
  - API response includes `lessonPlan` with concept names grouped by tier
  - When `priorKnowledge: "I have some experience"` is sent in request body, created nodes have non-zero proficiency
  - When no priorKnowledge sent, nodes have proficiency 0 and confidence 0
  </verify>
  <done>Initial proficiency inferred from prior knowledge, lesson plan summary included in API response</done>
</task>

<task type="auto">
  <name>Task 2: Zustand data loading action + verify live graph updates</name>
  <files>
    adaptive-tutor/src/lib/store.ts
    adaptive-tutor/src/app/(tabs)/graph/page.tsx
  </files>
  <action>
  1. In `store.ts`: Add a `loadStudyPlanData` async action:
     ```typescript
     loadStudyPlanData: async (planId: string) => {
       try {
         const res = await fetch(`/api/study-plans/${planId}`);
         if (!res.ok) throw new Error("Failed to load study plan");
         const { plan } = await res.json();

         set({
           activeStudyPlanId: planId,
           conceptNodes: plan.concepts ?? [],
           conceptEdges: plan.edges ?? [],
         });

         // Also add/update this plan in studyPlans array
         set((state) => ({
           studyPlans: state.studyPlans.some(p => p.id === planId)
             ? state.studyPlans.map(p => p.id === planId ? plan : p)
             : [...state.studyPlans, plan],
         }));
       } catch (error) {
         console.error("Failed to load study plan data:", error);
       }
     }
     ```

     Note: Since Zustand `create` expects synchronous initial state, the async action should be defined inside the store as a regular function that calls `set`. Zustand supports this pattern -- the action function itself is synchronous but performs async work internally. Add it to the AppState interface as `loadStudyPlanData: (planId: string) => Promise<void>`.

  2. In `graph/page.tsx`: Add an initial data load effect. When the page mounts and `activeStudyPlanId` is set but `conceptNodes` is empty, call `loadStudyPlanData`:
     ```typescript
     const loadStudyPlanData = useAppStore(state => state.loadStudyPlanData);

     useEffect(() => {
       if (activeStudyPlanId && conceptNodes.length === 0) {
         loadStudyPlanData(activeStudyPlanId);
       }
     }, [activeStudyPlanId]);
     ```
     This handles the case where the user refreshes the page on the Graph tab.

  3. Verify live update path (no code change needed, just verify the chain):
     - `updateConceptProficiency(id, prof, conf)` in store updates `conceptNodes` array
     - `flowNodes` useMemo in graph page depends on `conceptNodes` -> recomputes
     - `useEffect` syncs `flowNodes` -> `setNodes` -> React Flow re-renders
     - `proficiencyColor()` returns new color based on updated proficiency
     - ConceptNode component (now React.memo) receives new `data.concept` -> re-renders only that node

     If this chain is already correct (it should be from the existing code), no changes needed. If the useEffect/setNodes pattern causes full re-renders of all nodes, consider switching to a more granular update approach (but for hackathon, this is acceptable).

  4. Add a `loadStudyPlans` action to fetch all study plans on app init:
     ```typescript
     loadStudyPlans: async () => {
       try {
         const res = await fetch('/api/study-plans');
         if (!res.ok) throw new Error('Failed to load study plans');
         const { plans } = await res.json();
         set({ studyPlans: plans });

         // If there's an active plan, load its data
         if (plans.length > 0) {
           const activePlan = plans.find((p: { status: string }) => p.status === 'active') ?? plans[0];
           // Don't auto-load graph data here -- let the graph page do it on mount
           set({ activeStudyPlanId: activePlan.id });
         }
       } catch (error) {
         console.error('Failed to load study plans:', error);
       }
     }
     ```
     This is called once on app initialization (e.g., in a root layout effect or the first page load).
  </action>
  <verify>
  - `npx tsc --noEmit` passes
  - `loadStudyPlanData` exists in store and fetches from API correctly
  - Graph page loads data on mount when activeStudyPlanId is set
  - After calling `updateConceptProficiency`, graph node color changes without page refresh (verify via browser devtools or manual testing)
  </verify>
  <done>Zustand store can hydrate from API, graph data loads on page mount, proficiency updates propagate live to graph colors</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd adaptive-tutor && npx tsc --noEmit`
2. Graph generation with `priorKnowledge` in request body produces non-zero proficiency nodes
3. Graph page loads data from API on mount
4. Proficiency color updates propagate (test by calling `updateConceptProficiency` in browser console)
5. Lesson plan data included in generate-graph response
</verification>

<success_criteria>
- Initial proficiency reflects stated prior knowledge (not all gray/untested)
- Graph data loads from API (survives page refresh via loadStudyPlanData)
- Proficiency changes propagate to node colors in real time
- Lesson plan summary available in generate-graph API response
</success_criteria>

<output>
After completion, create `.planning/phases/02-graph-generation-and-visualization/02-04-SUMMARY.md`
</output>
