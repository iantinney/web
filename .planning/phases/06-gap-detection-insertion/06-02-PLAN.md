---
phase: 06-gap-detection-insertion
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - adaptive-tutor/src/components/GapProposalCard.tsx
  - adaptive-tutor/src/app/(tabs)/learn/page.tsx
  - adaptive-tutor/src/app/api/study-plans/[id]/concepts/insert/route.ts
  - adaptive-tutor/src/lib/store.ts
  - adaptive-tutor/src/lib/algorithms/graphValidator.ts
autonomous: true

must_haves:
  truths:
    - "When the same missingConcept appears in 2+ GapDetection records, a proposal card appears in the Learn tab"
    - "User can click Confirm on the proposal to insert the prerequisite concept into their graph"
    - "User can click Decline to dismiss the proposal"
    - "After confirming insertion, practice redirects to the new prerequisite concept"
    - "After mastering the prerequisite (proficiency >= 0.8), practice redirects back to the original concept"
    - "New concept appears in the graph with a prerequisite edge to the original struggling concept"
    - "Questions are generated for the newly inserted concept (fire-and-forget)"
  artifacts:
    - path: "adaptive-tutor/src/components/GapProposalCard.tsx"
      provides: "UI component showing gap proposal with confirm/decline buttons"
      min_lines: 40
    - path: "adaptive-tutor/src/app/api/study-plans/[id]/concepts/insert/route.ts"
      provides: "POST endpoint that inserts a concept with edges and layout"
      exports: ["POST"]
    - path: "adaptive-tutor/src/app/(tabs)/learn/page.tsx"
      provides: "Gap detection check after each attempt, proposal display, redirect logic"
      contains: "GapProposalCard"
    - path: "adaptive-tutor/src/lib/store.ts"
      provides: "redirectedFromConceptId state for tracking practice redirect origin"
      contains: "redirectedFromConceptId"
  key_links:
    - from: "adaptive-tutor/src/app/(tabs)/learn/page.tsx"
      to: "adaptive-tutor/src/components/GapProposalCard.tsx"
      via: "renders GapProposalCard when 2+ gaps detected for same prerequisite"
      pattern: "GapProposalCard"
    - from: "adaptive-tutor/src/app/(tabs)/learn/page.tsx"
      to: "/api/study-plans/[id]/concepts/insert"
      via: "POST fetch on user confirm"
      pattern: "concepts/insert"
    - from: "adaptive-tutor/src/app/api/study-plans/[id]/concepts/insert/route.ts"
      to: "findOrCreateConcept"
      via: "concept dedup on insertion"
      pattern: "findOrCreateConcept"
    - from: "adaptive-tutor/src/app/(tabs)/learn/page.tsx"
      to: "adaptive-tutor/src/lib/store.ts"
      via: "redirectedFromConceptId tracks where user was redirected from"
      pattern: "redirectedFromConceptId"
---

<objective>
Implement the user-facing gap detection flow: pattern detection (2+ occurrences), proposal UI, concept insertion endpoint, practice redirect to prerequisite, and redirect back on mastery.

Purpose: This is the visible "living graph" behavior. After this plan, users see the system detect their knowledge gaps, propose remediation, insert prerequisite concepts, and guide them through targeted practice.

Output: GapProposalCard component, concept insertion API endpoint, Learn page with gap detection + redirect logic, store with redirect tracking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-gap-detection-insertion/06-CONTEXT.md
@.planning/phases/06-gap-detection-insertion/06-01-SUMMARY.md
@adaptive-tutor/adaptive-graph-design.md (sections 2.1, 4.1, 5.1)
@adaptive-tutor/src/app/(tabs)/learn/page.tsx
@adaptive-tutor/src/lib/store.ts
@adaptive-tutor/src/lib/algorithms/conceptDedup.ts
@adaptive-tutor/src/lib/algorithms/graphValidator.ts
@adaptive-tutor/src/lib/types.ts
@adaptive-tutor/src/lib/schemas.ts
@adaptive-tutor/prisma/schema.prisma
@adaptive-tutor/src/app/api/study-plans/[id]/attempt/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Concept insertion endpoint + GapProposalCard component + store updates</name>
  <files>
    adaptive-tutor/src/app/api/study-plans/[id]/concepts/insert/route.ts
    adaptive-tutor/src/components/GapProposalCard.tsx
    adaptive-tutor/src/lib/store.ts
    adaptive-tutor/src/lib/algorithms/graphValidator.ts
  </files>
  <action>
**1a. Create POST /api/study-plans/[id]/concepts/insert/route.ts:**

This endpoint handles single concept insertion into an existing graph. It:
1. Validates the request (conceptName, parentConceptId, unitGraphId are required)
2. Checks if the concept already exists in this graph (if so, just create the edge + redirect)
3. Calls `findOrCreateConcept` from conceptDedup.ts for dedup against the shared concept pool
4. Creates GraphMembership linking the new concept to the unitGraph
5. Creates ConceptEdge (newConcept -> parentConcept, type "prerequisite")
6. Computes position for the new node using incremental layout
7. Updates GapDetection records status from "detected"/"proposed" to "accepted"
8. Fires background question generation for the new concept
9. Returns the new concept data + updated layout

Request body:
```typescript
{
  conceptName: string;         // Name of the prerequisite to insert
  parentConceptId: string;     // The concept the user was struggling with
  unitGraphId: string;         // Which graph to insert into
  gapDetectionIds?: string[];  // GapDetection record IDs to mark as accepted
}
```

Response:
```typescript
{
  concept: Concept;            // The inserted/found concept
  membership: GraphMembership; // New membership record
  edge: ConceptEdge;           // New prerequisite edge
  wasReused: boolean;          // Whether concept already existed in pool
  alreadyInGraph: boolean;     // Whether concept was already in this specific graph
}
```

Implementation details:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { findOrCreateConcept } from "@/lib/algorithms/conceptDedup";
import { computeDAGLayout } from "@/lib/algorithms/graphValidator";

export async function POST(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id: studyPlanId } = await params;
  const body = await req.json().catch(() => null);

  if (!body?.conceptName || !body?.parentConceptId || !body?.unitGraphId) {
    return NextResponse.json(
      { error: "Missing required fields: conceptName, parentConceptId, unitGraphId" },
      { status: 400 }
    );
  }

  const { conceptName, parentConceptId, unitGraphId, gapDetectionIds } = body;
  const userId = req.headers.get("x-user-id") ?? body.userId ?? "demo-user";

  // 1. Check if concept already exists in this graph
  const existingMembership = await prisma.graphMembership.findFirst({
    where: {
      unitGraphId,
      concept: { nameNormalized: conceptName.trim().toLowerCase(), userId },
    },
    include: { concept: true },
  });

  if (existingMembership) {
    // Concept already in graph — just ensure edge exists and return
    const existingEdge = await prisma.conceptEdge.findFirst({
      where: {
        fromNodeId: existingMembership.conceptId,
        toNodeId: parentConceptId,
        unitGraphId,
      },
    });

    if (!existingEdge) {
      await prisma.conceptEdge.create({
        data: {
          fromNodeId: existingMembership.conceptId,
          toNodeId: parentConceptId,
          unitGraphId,
          edgeType: "prerequisite",
        },
      });
    }

    // Update gap detection status
    if (gapDetectionIds?.length) {
      await prisma.gapDetection.updateMany({
        where: { id: { in: gapDetectionIds } },
        data: { status: "accepted" },
      });
    }

    return NextResponse.json({
      concept: existingMembership.concept,
      membership: existingMembership,
      edge: existingEdge,
      wasReused: true,
      alreadyInGraph: true,
    });
  }

  // 2. Find or create concept in the shared pool
  const { id: conceptId, wasReused } = await findOrCreateConcept(
    userId,
    conceptName,
    `Prerequisite concept identified by gap detection`,
    [],  // keyTerms will be populated when questions are generated
    0.0, // Start at zero proficiency
    0.0  // Zero confidence
  );

  // 3. Get parent concept's membership to determine position
  const parentMembership = await prisma.graphMembership.findFirst({
    where: { conceptId: parentConceptId, unitGraphId },
  });

  // Position the new node below and slightly left of the parent
  const newX = (parentMembership?.positionX ?? 0) - 140;
  const newY = (parentMembership?.positionY ?? 0) + 180;
  const parentTier = parentMembership?.depthTier ?? 1;

  // 4. Create membership + edge in a transaction
  const [membership, edge] = await prisma.$transaction([
    prisma.graphMembership.create({
      data: {
        conceptId,
        unitGraphId,
        positionX: newX,
        positionY: newY,
        depthTier: Math.max(0, parentTier - 1), // One tier below parent (closer to foundation)
        addedBy: "gap_detection",
      },
    }),
    prisma.conceptEdge.create({
      data: {
        fromNodeId: conceptId,
        toNodeId: parentConceptId,
        unitGraphId,
        edgeType: "prerequisite",
      },
    }),
  ]);

  // 5. Update gap detection records
  if (gapDetectionIds?.length) {
    await prisma.gapDetection.updateMany({
      where: { id: { in: gapDetectionIds } },
      data: { status: "accepted" },
    });
  }

  // 6. Fire-and-forget: generate questions for the new concept
  const concept = await prisma.concept.findUnique({ where: { id: conceptId } });
  if (concept) {
    fetch(`${process.env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000"}/api/study-plans/${studyPlanId}/generate-questions`, {
      method: "POST",
      headers: { "Content-Type": "application/json", "x-user-id": userId },
      body: JSON.stringify({ userId, conceptIds: [conceptId] }),
    }).catch((err) => {
      console.error("[insert] Background question generation failed:", err);
    });
  }

  return NextResponse.json({
    concept,
    membership,
    edge,
    wasReused,
    alreadyInGraph: false,
  });
}
```

**1b. Create src/components/GapProposalCard.tsx:**

A card component shown inline in the Learn tab when a gap pattern is detected. It displays:
- The struggling concept name
- The proposed prerequisite name
- The system's reasoning (from GapDetection explanation)
- Confirm and Decline buttons

Props interface:
```typescript
interface GapProposalCardProps {
  parentConceptName: string;     // The concept user is struggling with
  missingConceptName: string;    // The proposed prerequisite
  explanation: string;           // Why the system thinks this is needed
  occurrenceCount: number;       // How many times the gap was detected
  onConfirm: () => void;        // Called when user clicks Confirm
  onDecline: () => void;        // Called when user clicks Decline
  isLoading?: boolean;           // Show loading state during insertion
}
```

Visual design:
- Rounded card with amber/yellow border (warning-ish, but friendly)
- Light bulb icon (Lightbulb from lucide-react)
- Title: "Knowledge Gap Detected"
- Body: "I've noticed your answers about **{parentConceptName}** suggest you might need more background in **{missingConceptName}**."
- Subtext: "{explanation}" in lighter text
- Badge: "Detected {occurrenceCount} times"
- Two buttons: "Add to My Path" (primary/accent colored) and "Skip for Now" (ghost/secondary)
- When isLoading: Show spinner on the confirm button, disable both buttons

Use the project's existing CSS variable pattern (not Tailwind color classes):
- `var(--bg-card)` for background
- `var(--border)` for borders
- `var(--text-primary)` / `var(--text-secondary)` for text
- `var(--accent)` for the confirm button
- `var(--warning)` or amber-500 for the card highlight border

**1c. Add redirect tracking to src/lib/store.ts:**

Add two new fields to the AppState interface:

```typescript
// Gap detection redirect tracking
redirectedFromConceptId: string | null;    // Original concept user was practicing before redirect
redirectedFromConceptName: string | null;  // Name for display
```

Add corresponding actions:
```typescript
setRedirectedFrom: (conceptId: string | null, conceptName: string | null) => void;
```

Add initial state values (both null) and the setter implementation:
```typescript
setRedirectedFrom: (conceptId, conceptName) => set({
  redirectedFromConceptId: conceptId,
  redirectedFromConceptName: conceptName
}),
```

**1d. Add incremental layout helper to src/lib/algorithms/graphValidator.ts:**

Add a new exported function `computeIncrementalPosition` that finds an open position near a parent node without moving existing nodes:

```typescript
/**
 * Compute position for a new node relative to a parent node.
 * Checks existing positions to avoid overlap.
 * Returns { x, y } for the new node.
 */
export function computeIncrementalPosition(
  parentPosition: { x: number; y: number },
  existingPositions: { x: number; y: number }[],
  options?: { layerGap?: number; nodeGap?: number }
): { x: number; y: number } {
  const LAYER_GAP = options?.layerGap ?? 180;
  const NODE_GAP = options?.nodeGap ?? 280;

  // Try positions below the parent, starting directly below then spreading
  const baseY = parentPosition.y + LAYER_GAP;
  const offsets = [0, -NODE_GAP, NODE_GAP, -NODE_GAP * 2, NODE_GAP * 2];

  for (const offsetX of offsets) {
    const candidateX = parentPosition.x + offsetX;
    const candidateY = baseY;

    // Check if this position overlaps with any existing node
    const overlaps = existingPositions.some(
      (pos) => Math.abs(pos.x - candidateX) < NODE_GAP * 0.7 && Math.abs(pos.y - candidateY) < LAYER_GAP * 0.7
    );

    if (!overlaps) {
      return { x: candidateX, y: candidateY };
    }
  }

  // Fallback: place further below
  return { x: parentPosition.x, y: baseY + LAYER_GAP };
}
```
  </action>
  <verify>
1. `cd /home/antel/hackathon/adaptive-tutor && npx tsc --noEmit` passes.
2. Verify GapProposalCard renders: Temporarily add `<GapProposalCard parentConceptName="Test" missingConceptName="Test2" explanation="test" occurrenceCount={2} onConfirm={() => {}} onDecline={() => {}} />` to Learn page idle screen and check it renders without errors.
3. Verify insert endpoint: `curl -X POST http://localhost:3000/api/study-plans/PLAN_ID/concepts/insert -H "Content-Type: application/json" -H "x-user-id: demo-user" -d '{"conceptName":"Test Concept","parentConceptId":"SOME_ID","unitGraphId":"SOME_ID"}'` returns a response (even if 404 for missing IDs, the route should load without import errors).
  </verify>
  <done>
Concept insertion endpoint created, GapProposalCard component renders, store has redirect tracking fields, incremental layout helper added. All compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire gap detection flow into Learn page</name>
  <files>
    adaptive-tutor/src/app/(tabs)/learn/page.tsx
  </files>
  <action>
This is the integration task. Wire everything together in the Learn page:

**2a. Update the AttemptResult interface (top of learn/page.tsx):**

Add the new fields from Plan 01's enhanced attempt response:

```typescript
interface AttemptResult {
  isCorrect: boolean;
  feedback: string;
  explanation: string | null;
  score: number;
  errorType?: "CORRECT" | "MINOR" | "MISCONCEPTION" | "PREREQUISITE_GAP";
  gapAnalysis?: {
    missingConcept: string;
    severity: "NARROW" | "MODERATE" | "BROAD";
    explanation: string;
  };
  proficiencyUpdate: {
    conceptId: string;
    previousProficiency: number;
    newProficiency: number;
    previousConfidence: number;
    newConfidence: number;
  };
  sessionUpdate: {
    sessionId: string;
    questionsAttempted: number;
    questionsCorrect: number;
    accuracy: number;
  };
}
```

**2b. Add imports:**

```typescript
import { GapProposalCard } from "@/components/GapProposalCard";
import { Lightbulb } from "lucide-react"; // Add to existing lucide imports
```

**2c. Add gap detection state variables inside LearnPage function:**

```typescript
// Gap detection state
const [pendingGapProposal, setPendingGapProposal] = useState<{
  parentConceptId: string;
  parentConceptName: string;
  missingConceptName: string;
  explanation: string;
  occurrenceCount: number;
  gapDetectionIds: string[];
} | null>(null);
const [isInsertingConcept, setIsInsertingConcept] = useState(false);
const [gapDetectedInline, setGapDetectedInline] = useState<string | null>(null); // Show subtle "gap detected" note
```

Add store destructuring for the new fields:
```typescript
const {
  // ... existing destructured fields ...
  redirectedFromConceptId,
  redirectedFromConceptName,
  setRedirectedFrom,
  activeUnitGraphId,
  loadUnitGraphData,
} = useAppStore();
```

**2d. After each attempt submission, check for gap pattern:**

Inside `submitAttempt`, after receiving the result and BEFORE the feedback/advance logic (after line ~295 where proficiency is updated), add gap checking logic:

```typescript
// Check for gap pattern after incorrect free_response with PREREQUISITE_GAP
if (
  result.errorType === "PREREQUISITE_GAP" &&
  result.gapAnalysis &&
  currentQuestion?.conceptId
) {
  // Show subtle inline indicator
  setGapDetectedInline(result.gapAnalysis.missingConcept);

  // Check for 2+ occurrences pattern
  try {
    const gapRes = await fetch(
      `/api/study-plans/${activeStudyPlanId}/gap-detections?conceptId=${currentQuestion.conceptId}&missingConcept=${encodeURIComponent(result.gapAnalysis.missingConcept)}&userId=${userId}`,
      { headers: { "x-user-id": userId } }
    );
    if (gapRes.ok) {
      const gapData = await gapRes.json();
      if (gapData.count >= 2) {
        // Pattern detected! Show proposal
        setPendingGapProposal({
          parentConceptId: currentQuestion.conceptId,
          parentConceptName: currentQuestion.conceptName ?? "this concept",
          missingConceptName: result.gapAnalysis.missingConcept,
          explanation: result.gapAnalysis.explanation,
          occurrenceCount: gapData.count,
          gapDetectionIds: gapData.ids,
        });
      }
    }
  } catch (err) {
    console.warn("Gap pattern check failed:", err);
    // Non-blocking — continue without gap proposal
  }
}
```

**IMPORTANT: You also need to create the gap-detections query endpoint.** Create a new GET route at:
`adaptive-tutor/src/app/api/study-plans/[id]/gap-detections/route.ts`

This is a simple query endpoint:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

/**
 * GET /api/study-plans/[id]/gap-detections
 * Query gap detection records for pattern matching.
 *
 * Query params:
 * - conceptId: The concept being practiced
 * - missingConcept: The prerequisite concept name to check
 * - userId: The user ID
 */
export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const url = new URL(req.url);
  const conceptId = url.searchParams.get("conceptId");
  const missingConcept = url.searchParams.get("missingConcept");
  const userId = req.headers.get("x-user-id") ?? url.searchParams.get("userId") ?? "demo-user";

  if (!conceptId || !missingConcept) {
    return NextResponse.json(
      { error: "Missing required params: conceptId, missingConcept" },
      { status: 400 }
    );
  }

  const gaps = await prisma.gapDetection.findMany({
    where: {
      userId,
      conceptId,
      missingConcept: { equals: missingConcept },
      status: "detected",
    },
    orderBy: { createdAt: "desc" },
  });

  return NextResponse.json({
    count: gaps.length,
    ids: gaps.map((g) => g.id),
    gaps,
  });
}
```

Add this file to the files_modified list in your execution: `adaptive-tutor/src/app/api/study-plans/[id]/gap-detections/route.ts`

**2e. Add proposal confirmation handler:**

```typescript
const handleConfirmInsertion = useCallback(async () => {
  if (!pendingGapProposal || !activeStudyPlanId || !activeUnitGraphId) return;
  setIsInsertingConcept(true);

  try {
    const userId = getUserId();
    const res = await fetch(
      `/api/study-plans/${activeStudyPlanId}/concepts/insert`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json", "x-user-id": userId },
        body: JSON.stringify({
          conceptName: pendingGapProposal.missingConceptName,
          parentConceptId: pendingGapProposal.parentConceptId,
          unitGraphId: activeUnitGraphId,
          gapDetectionIds: pendingGapProposal.gapDetectionIds,
          userId,
        }),
      }
    );

    if (res.ok) {
      const insertResult = await res.json();

      // Track where user was redirected from
      setRedirectedFrom(
        pendingGapProposal.parentConceptId,
        pendingGapProposal.parentConceptName
      );

      // Set target to newly inserted concept for focused practice
      setTargetConceptId(insertResult.concept.id);

      // Refresh the graph data so new node appears
      if (activeUnitGraphId) {
        loadUnitGraphData(activeUnitGraphId);
      }

      // Clear proposal and restart session targeting the new concept
      setPendingGapProposal(null);
      setGapDetectedInline(null);

      // End current session and start new one focused on prerequisite
      handleNewSession();
    } else {
      console.error("Concept insertion failed:", await res.text());
    }
  } catch (err) {
    console.error("Concept insertion error:", err);
  } finally {
    setIsInsertingConcept(false);
  }
}, [pendingGapProposal, activeStudyPlanId, activeUnitGraphId, setRedirectedFrom, setTargetConceptId, loadUnitGraphData, handleNewSession]);

const handleDeclineInsertion = useCallback(() => {
  // Mark gap detections as declined
  if (pendingGapProposal?.gapDetectionIds?.length && activeStudyPlanId) {
    const userId = getUserId();
    fetch(`/api/study-plans/${activeStudyPlanId}/concepts/insert`, {
      method: "POST",
      headers: { "Content-Type": "application/json", "x-user-id": userId },
      body: JSON.stringify({
        decline: true,
        gapDetectionIds: pendingGapProposal.gapDetectionIds,
      }),
    }).catch(() => {});
    // Note: The insert endpoint should handle decline=true by just updating status
    // OR create a separate decline endpoint. For simplicity, just clear the UI.
  }
  setPendingGapProposal(null);
  setGapDetectedInline(null);
}, [pendingGapProposal, activeStudyPlanId]);
```

**ALTERNATIVE for decline:** Instead of calling the insert endpoint, update the gap-detections directly. Add a PATCH handler to the gap-detections route or simply clear the UI and let the gaps stay as "detected" (they won't re-trigger the proposal since the user has already seen it this session). For hackathon simplicity, just clear the UI state on decline.

**2f. Render the GapProposalCard in the feedback phase:**

In the feedback phase render section (after the feedback card but before the "Continue" button), add:

```tsx
{/* Gap Proposal Card — shown when 2+ gap pattern detected */}
{pendingGapProposal && (
  <div className="w-full max-w-md mt-4">
    <GapProposalCard
      parentConceptName={pendingGapProposal.parentConceptName}
      missingConceptName={pendingGapProposal.missingConceptName}
      explanation={pendingGapProposal.explanation}
      occurrenceCount={pendingGapProposal.occurrenceCount}
      onConfirm={handleConfirmInsertion}
      onDecline={handleDeclineInsertion}
      isLoading={isInsertingConcept}
    />
  </div>
)}
```

Also show a subtle inline gap indicator during feedback when a single gap is detected (first occurrence, no proposal yet):

```tsx
{/* Subtle gap detected indicator (first occurrence, no proposal yet) */}
{gapDetectedInline && !pendingGapProposal && (
  <div
    className="flex items-center gap-2 text-xs px-3 py-2 rounded-lg mt-2"
    style={{ backgroundColor: "var(--bg-tertiary)", color: "var(--text-secondary)" }}
  >
    <Lightbulb size={14} />
    <span>Gap noted: <strong>{gapDetectedInline}</strong> — tracking for pattern</span>
  </div>
)}
```

**2g. Mastery redirect logic:**

After each attempt's proficiency update, check if the user was redirected and the prerequisite is now mastered:

In `submitAttempt`, after the proficiency update block and before the feedback/advance logic, add:

```typescript
// Check if user was redirected and has now mastered the prerequisite
if (
  redirectedFromConceptId &&
  result.proficiencyUpdate.newProficiency >= 0.8 &&
  currentQuestion?.conceptId
) {
  // Check if the mastered concept is the one they were redirected to practice
  // (it should be, since targetConceptId is set)
  if (targetConceptId === currentQuestion.conceptId || !targetConceptId) {
    // Prerequisite mastered! Redirect back to original concept
    setTargetConceptId(redirectedFromConceptId);
    setRedirectedFrom(null, null);

    // The session will restart when handleNewSession is called
    // Show a mastery congratulation (set a flag that the complete screen will display)
  }
}
```

Also in the "complete" phase render, add a mastery redirect message if redirectedFromConceptId was just cleared:

```tsx
{/* After session complete, if there's a redirectedFromConceptId, offer to go back */}
{redirectedFromConceptId && redirectedFromConceptName && (
  <div
    className="w-full max-w-md rounded-2xl border p-4 text-center"
    style={{ backgroundColor: "var(--bg-card)", borderColor: "var(--accent)" }}
  >
    <p className="text-sm font-medium" style={{ color: "var(--text-primary)" }}>
      Great progress! Ready to try <strong>{redirectedFromConceptName}</strong> again?
    </p>
    <button
      onClick={() => {
        setTargetConceptId(redirectedFromConceptId);
        setRedirectedFrom(null, null);
        handleNewSession();
      }}
      className="mt-3 px-6 py-2 rounded-xl text-sm font-semibold"
      style={{ backgroundColor: "var(--accent)", color: "#ffffff" }}
    >
      Return to {redirectedFromConceptName}
    </button>
  </div>
)}
```

**2h. Target concept banner for redirected practice:**

In the practicing phase header area (near the targetConceptId banner that already exists around the progress bar), add a redirected-from banner:

```tsx
{/* Redirect practice banner */}
{redirectedFromConceptName && targetConceptId && (
  <div
    className="flex items-center gap-2 text-xs px-3 py-2 rounded-lg"
    style={{ backgroundColor: "var(--accent-soft)", color: "var(--accent)" }}
  >
    <Lightbulb size={14} />
    <span>Building prerequisite knowledge before returning to <strong>{redirectedFromConceptName}</strong></span>
  </div>
)}
```

**Key implementation notes:**
- The gap check is async but non-blocking — if it fails, practice continues normally.
- The GapProposalCard appears in the feedback phase, giving the user time to see their wrong answer feedback first.
- On confirm, the current session ends and a new one starts targeting the prerequisite concept.
- The `redirectedFromConceptId` persists across sessions via Zustand store (not persisted to DB — page refresh clears it, which is acceptable for hackathon).
- The mastery check uses proficiency >= 0.8 which is the existing mastery threshold from Phase 5.
- Clear `gapDetectedInline` on each new question (reset it in the questionIndex useEffect).
  </action>
  <verify>
1. `cd /home/antel/hackathon/adaptive-tutor && npx tsc --noEmit` passes.
2. `cd /home/antel/hackathon/adaptive-tutor && npm run build` succeeds.
3. Full flow test:
   a. Start the app, go to Learn tab, begin practice
   b. Answer a free_response question wrong — check Network tab for `errorType` in response
   c. If PREREQUISITE_GAP detected, check that GapDetection record exists in Prisma Studio
   d. Answer another free_response wrong with the same gap — proposal card should appear
   e. Click "Add to My Path" — concept should be inserted (check Prisma Studio for GraphMembership + ConceptEdge)
   f. Practice should restart targeting the new concept
   g. Check graph tab — new node should be visible
  </verify>
  <done>
Gap detection flow fully wired: 2-occurrence pattern detection shows GapProposalCard, user can confirm to insert concept, practice redirects to prerequisite, mastery redirects back. Graph updates with new node. Build passes with zero errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (no TypeScript errors)
2. `npm run build` succeeds (no build errors)
3. GapProposalCard renders with correct styling and button functionality
4. Concept insertion endpoint creates Concept + GraphMembership + ConceptEdge
5. Gap pattern detection correctly identifies 2+ occurrences
6. Proposal card appears in Learn tab after 2nd gap detection
7. Confirm inserts concept and redirects practice
8. Decline clears the proposal
9. Mastery redirect works when prerequisite proficiency reaches 0.8
10. Graph tab shows newly inserted node
11. Questions are generated for new concept (fire-and-forget)
</verification>

<success_criteria>
- GapProposalCard appears when 2+ identical prerequisite gaps are detected
- User can confirm insertion: new concept appears in graph with prerequisite edge
- Practice redirects to new prerequisite concept after insertion
- Prerequisite mastery (>= 0.8) triggers redirect back to original concept
- Graph visualization shows newly inserted node with correct positioning
- Questions are generated for the new concept asynchronously
- Decline clears the proposal without inserting
- Build passes with zero TypeScript/runtime errors
- No regression in existing practice flow for non-free-response questions
</success_criteria>

<output>
After completion, create `.planning/phases/06-gap-detection-insertion/06-02-SUMMARY.md`
</output>
