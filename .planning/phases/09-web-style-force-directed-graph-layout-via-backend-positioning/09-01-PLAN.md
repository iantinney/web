---
phase: 09-web-style-force-directed-graph-layout-via-backend-positioning
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - adaptive-tutor/src/lib/algorithms/forceLayout.ts
  - adaptive-tutor/src/app/api/unit-graphs/[id]/layout/route.ts
  - adaptive-tutor/src/app/api/study-plans/[id]/structure-plan/route.ts
  - adaptive-tutor/src/app/api/study-plans/[id]/concepts/insert/route.ts
  - adaptive-tutor/package.json
autonomous: true
requirements:
  - LAYOUT-01
  - LAYOUT-05

must_haves:
  truths:
    - "Graph positions are computed by d3-force with forceRadial (prerequisites near center, advanced outer)"
    - "Positions persist to GraphMembership.positionX/positionY in the database"
    - "Layout recomputes on graph mutation (creation and concept insertion)"
    - "Adaptive spacing scales with graph size (small graphs spacious, large graphs compress)"
    - "POST /api/unit-graphs/[id]/layout returns computed positions"
  artifacts:
    - path: "adaptive-tutor/src/lib/algorithms/forceLayout.ts"
      provides: "computeForceLayout() function using d3-force simulation"
      exports: ["computeForceLayout"]
    - path: "adaptive-tutor/src/app/api/unit-graphs/[id]/layout/route.ts"
      provides: "POST endpoint for on-demand layout recomputation"
      exports: ["POST"]
  key_links:
    - from: "adaptive-tutor/src/app/api/study-plans/[id]/structure-plan/route.ts"
      to: "adaptive-tutor/src/lib/algorithms/forceLayout.ts"
      via: "import computeForceLayout replaces computeDAGLayout"
      pattern: "import.*computeForceLayout.*from.*forceLayout"
    - from: "adaptive-tutor/src/app/api/study-plans/[id]/concepts/insert/route.ts"
      to: "adaptive-tutor/src/lib/algorithms/forceLayout.ts"
      via: "import computeForceLayout replaces computeDAGLayout"
      pattern: "import.*computeForceLayout.*from.*forceLayout"
    - from: "adaptive-tutor/src/app/api/unit-graphs/[id]/layout/route.ts"
      to: "adaptive-tutor/src/lib/algorithms/forceLayout.ts"
      via: "import computeForceLayout for on-demand recompute"
      pattern: "import.*computeForceLayout.*from.*forceLayout"
---

<objective>
Create the backend force-directed layout engine using d3-force and migrate all layout callers from the old Dagre-style `computeDAGLayout` to the new `computeForceLayout`.

Purpose: Replace the hierarchical top-down flowchart layout with an organic web-style layout where prerequisites gravitate toward the center and advanced concepts radiate outward — the foundation of the neural network visual metaphor.

Output: `forceLayout.ts` module, `/api/unit-graphs/[id]/layout` endpoint, migrated callers in `structure-plan` and `concepts/insert` routes. Old `computeDAGLayout` kept for reference but no longer imported anywhere.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-web-style-force-directed-graph-layout-via-backend-positioning/09-RESEARCH.md
@adaptive-tutor/src/lib/algorithms/graphValidator.ts
@adaptive-tutor/src/app/api/study-plans/[id]/structure-plan/route.ts
@adaptive-tutor/src/app/api/study-plans/[id]/concepts/insert/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install d3-force and create computeForceLayout module</name>
  <files>
    adaptive-tutor/package.json
    adaptive-tutor/src/lib/algorithms/forceLayout.ts
  </files>
  <action>
1. Install d3-force and its types:
   ```bash
   cd adaptive-tutor && npm install d3-force @types/d3-force
   ```

2. Remove dagre and @types/dagre from package.json (no code imports them — dagre is unused):
   ```bash
   cd adaptive-tutor && npm uninstall dagre @types/dagre
   ```

3. Create `adaptive-tutor/src/lib/algorithms/forceLayout.ts` with:

   - Interface `LayoutNode extends SimulationNodeDatum` with `id: string` and `depthTier: number` (1=foundation, 2=intermediate, 3=advanced).
   - Interface `LayoutLink extends SimulationLinkDatum<LayoutNode>` with `source: string` and `target: string`.
   - Export function `computeForceLayout(nodes: LayoutNode[], links: LayoutLink[], options?: { width?: number; height?: number }): Map<string, { x: number; y: number }>`.

   Implementation details (per user decision: "semi-structured force-directed with gravity pulling prerequisites toward center"):
   - Import from `d3-force`: `forceSimulation`, `forceLink`, `forceManyBody`, `forceCenter`, `forceCollide`, `forceRadial`.
   - **Adaptive spacing** (per user decision): Scale factor = `Math.max(1, Math.sqrt(nodeCount / 10))`. Base radius = `150 * scaleFactor`.
   - **Forces:**
     - `forceManyBody`: strength `-300 * scaleFactor`, distanceMax `500 * scaleFactor`.
     - `forceLink`: id accessor `d => d.id`, distance `80 * scaleFactor`, strength `0.7`.
     - `forceCenter`: centered at (0, 0).
     - `forceCollide`: radius 75 (half average node width + padding, per research recommendation).
     - `forceRadial`: Per-node radius function based on `depthTier`:
       - tier 1 (foundation): `baseRadius * 0.3`
       - tier 2 (intermediate): `baseRadius * 0.7`
       - tier 3+ (advanced): `baseRadius * 1.0`
       - strength 0.3
   - **Synchronous run** (per research): Call `.stop()` immediately, then compute tick count = `Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay()))` (~300 ticks). Run a for-loop of that many `.tick()` calls.
   - **CRITICAL pitfall**: Create fresh plain objects for the simulation nodes (spread only `id` and `depthTier`). d3-force mutates nodes in-place adding `x`, `y`, `vx`, `vy`, `index` — never pass Prisma objects directly.
   - Extract final positions from mutated node objects into a `Map<string, { x: number; y: number }>`.

   The old `computeDAGLayout` in `graphValidator.ts` stays for reference but will no longer be imported by any route. Do NOT delete it — it serves as fallback documentation.
  </action>
  <verify>
    <automated>cd adaptive-tutor && npx tsx -e "const { computeForceLayout } = require('./src/lib/algorithms/forceLayout'); const nodes = [{id:'a',depthTier:1},{id:'b',depthTier:2},{id:'c',depthTier:3}]; const links = [{source:'a',target:'b'},{source:'b',target:'c'}]; const pos = computeForceLayout(nodes, links); console.log('Positions:', JSON.stringify(Object.fromEntries(pos))); const a = pos.get('a'); const c = pos.get('c'); const aDistFromCenter = Math.sqrt(a.x*a.x + a.y*a.y); const cDistFromCenter = Math.sqrt(c.x*c.x + c.y*c.y); console.log('Tier1 dist:', aDistFromCenter.toFixed(0), 'Tier3 dist:', cDistFromCenter.toFixed(0)); if(cDistFromCenter > aDistFromCenter) console.log('PASS: tier3 further from center than tier1'); else console.log('FAIL: radial ordering broken');"</automated>
    <manual>Verify that tier 1 nodes cluster near center and tier 3 nodes are placed further away</manual>
  </verify>
  <done>computeForceLayout() produces positions where depthTier 1 nodes are closer to center than depthTier 3 nodes, adaptive spacing works for varying graph sizes, and d3-force is installed.</done>
</task>

<task type="auto">
  <name>Task 2: Create layout API endpoint and migrate all computeDAGLayout callers</name>
  <files>
    adaptive-tutor/src/app/api/unit-graphs/[id]/layout/route.ts
    adaptive-tutor/src/app/api/study-plans/[id]/structure-plan/route.ts
    adaptive-tutor/src/app/api/study-plans/[id]/concepts/insert/route.ts
  </files>
  <action>
1. Create `adaptive-tutor/src/app/api/unit-graphs/[id]/layout/route.ts`:
   - `POST` handler: Receives `{ params: { id: string } }` (unitGraphId). Must `await params` (Next.js 16 requirement).
   - Fetch all `graphMemberships` (with concept include) and `conceptEdges` for this unitGraph.
   - Build `nodes` array: `memberships.map(m => ({ id: m.conceptId, depthTier: m.depthTier }))`.
   - Build `links` array: `edges.map(e => ({ source: e.fromNodeId, target: e.toNodeId }))`.
   - Call `computeForceLayout(nodes, links)`.
   - Batch-persist positions using `prisma.$transaction` (per research pitfall #5 — avoids SQLite single-writer lock bottleneck):
     ```typescript
     await prisma.$transaction(
       memberships.map(m => {
         const pos = positions.get(m.conceptId) ?? { x: 0, y: 0 };
         return prisma.graphMembership.update({
           where: { conceptId_unitGraphId: { conceptId: m.conceptId, unitGraphId: id } },
           data: { positionX: pos.x, positionY: pos.y },
         });
       })
     );
     ```
   - Return `NextResponse.json({ layout })` where layout is `Record<string, {x,y}>`.

2. Migrate `structure-plan/route.ts` (line ~163):
   - Replace `import { ... computeDAGLayout } from "@/lib/algorithms/graphValidator"` with `import { computeForceLayout } from "@/lib/algorithms/forceLayout"`.
   - Keep `validateDAG` and `breakCycles` imports from `graphValidator` — those are still needed.
   - Replace the `computeDAGLayout(tempNodes, validEdges)` call with:
     ```typescript
     const positions = computeForceLayout(
       tempNodes.map((n, i) => ({
         id: n.id,
         depthTier: graphData.concepts[i]?.difficultyTier ?? 1,
       })),
       validEdges.map(e => ({ source: e.from, target: e.to }))
     );
     ```
     Note: the old code passes `{ id, name }` objects but forceLayout needs `{ id, depthTier }`. Map tempNodes using graphData.concepts for tier data (same index correspondence since tempNodes is built from graphData.concepts).

3. Migrate `concepts/insert/route.ts` (line ~137):
   - Replace `import { computeDAGLayout } from "@/lib/algorithms/graphValidator"` with `import { computeForceLayout } from "@/lib/algorithms/forceLayout"`.
   - Replace the `computeDAGLayout(...)` call with:
     ```typescript
     const positions = computeForceLayout(
       memberships.map(m => ({ id: m.conceptId, depthTier: m.depthTier })),
       allEdges.map(e => ({ source: e.fromNodeId, target: e.toNodeId }))
     );
     ```
   - Replace `Promise.all(memberships.map(...update))` with `prisma.$transaction(...)` for batched position persistence (same pattern as layout endpoint).

4. Verify no remaining imports of `computeDAGLayout` in any route file (search codebase to confirm).
  </action>
  <verify>
    <automated>cd adaptive-tutor && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Verify structure-plan and concepts/insert routes compile with new forceLayout import; no remaining computeDAGLayout imports in src/app/</manual>
  </verify>
  <done>All three callers use computeForceLayout. Layout API endpoint exists at POST /api/unit-graphs/[id]/layout. No remaining computeDAGLayout imports in route files. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `cd adaptive-tutor && npx tsc --noEmit` — zero TypeScript errors
2. `grep -r "computeDAGLayout" adaptive-tutor/src/app/` — returns zero matches (only graphValidator.ts still has the function definition)
3. `computeForceLayout` produces radially-structured positions (tier 1 nearer center)
4. d3-force installed; dagre uninstalled from package.json
</verification>

<success_criteria>
- d3-force replaces dagre as the layout engine
- All graph creation and mutation paths use computeForceLayout
- Positions reflect semi-structured force-directed layout with radial tier separation
- Layout API endpoint enables on-demand recompute for future callers (Plan 03)
- No regression: existing graph generation and concept insertion still work
</success_criteria>

<output>
After completion, create `.planning/phases/09-web-style-force-directed-graph-layout-via-backend-positioning/09-01-SUMMARY.md`
</output>
