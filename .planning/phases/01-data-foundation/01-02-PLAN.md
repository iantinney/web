---
phase: 01-data-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - adaptive-tutor/src/app/api/study-plans/route.ts
  - adaptive-tutor/src/app/api/study-plans/[id]/route.ts
  - adaptive-tutor/src/app/api/study-plans/[id]/generate-graph/route.ts
  - adaptive-tutor/src/app/api/chat/route.ts
  - adaptive-tutor/src/app/api/attempts/route.ts
  - adaptive-tutor/src/app/api/chat/threads/route.ts
  - adaptive-tutor/src/app/api/chat/threads/[threadId]/messages/route.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/study-plans returns study plans from SQLite database"
    - "POST /api/study-plans creates a study plan in SQLite and returns it"
    - "GET /api/study-plans/[id] returns a study plan with its concepts and edges"
    - "PATCH /api/study-plans/[id] updates a study plan in SQLite"
    - "DELETE /api/study-plans/[id] cascade-deletes study plan and related data"
    - "POST /api/chat/threads creates a chat thread in SQLite"
    - "GET /api/chat/threads returns chat threads for the demo user"
    - "POST /api/chat/threads/[threadId]/messages creates a message and returns thread messages"
    - "GET /api/chat/threads/[threadId]/messages returns all messages for a thread"
    - "POST /api/attempts records an attempt and updates concept proficiency in SQLite"
    - "Message history persists across server restarts (CHAT-06)"
    - "Concept graph data persists across server restarts (GRAPH-04)"
  artifacts:
    - path: "adaptive-tutor/src/app/api/study-plans/route.ts"
      provides: "Study plan list and create endpoints using Prisma"
      exports: ["GET", "POST"]
    - path: "adaptive-tutor/src/app/api/study-plans/[id]/route.ts"
      provides: "Study plan detail, update, delete endpoints using Prisma"
      exports: ["GET", "PATCH", "DELETE"]
    - path: "adaptive-tutor/src/app/api/chat/threads/route.ts"
      provides: "Chat thread list and create endpoints"
      exports: ["GET", "POST"]
    - path: "adaptive-tutor/src/app/api/chat/threads/[threadId]/messages/route.ts"
      provides: "Chat message list and create endpoints"
      exports: ["GET", "POST"]
    - path: "adaptive-tutor/src/app/api/attempts/route.ts"
      provides: "Attempt submission with proficiency update using Prisma"
      exports: ["POST"]
  key_links:
    - from: "adaptive-tutor/src/app/api/study-plans/route.ts"
      to: "adaptive-tutor/src/lib/prisma.ts"
      via: "import prisma singleton"
      pattern: "import.*prisma.*from.*@/lib/prisma"
    - from: "adaptive-tutor/src/app/api/chat/threads/route.ts"
      to: "adaptive-tutor/src/lib/prisma.ts"
      via: "import prisma singleton"
      pattern: "prisma\\.chatThread\\.(findMany|create)"
    - from: "adaptive-tutor/src/app/api/attempts/route.ts"
      to: "adaptive-tutor/src/lib/prisma.ts"
      via: "Prisma transaction for attempt + proficiency update"
      pattern: "prisma\\.(attemptRecord|conceptNode)"
---

<objective>
Migrate all existing API routes from JSON file CRUD to Prisma queries, and add missing ChatThread/ChatMessage CRUD endpoints. This completes the persistence layer by ensuring every data operation goes through Prisma + SQLite.

Purpose: API routes currently import from the old JSON-based `db.ts`. After Plan 01 rewrites db.ts, these routes need to use Prisma directly (or through the updated db.ts wrappers). Additionally, the chat persistence requirement (CHAT-06) needs dedicated thread/message CRUD endpoints that don't exist yet.

Output: All API routes use Prisma for database operations. Chat thread and message CRUD endpoints exist and work. Requirements CHAT-06 and GRAPH-04 are satisfied.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-01-SUMMARY.md

Key existing files to reference:
@adaptive-tutor/src/app/api/study-plans/route.ts
@adaptive-tutor/src/app/api/study-plans/[id]/route.ts
@adaptive-tutor/src/app/api/study-plans/[id]/generate-graph/route.ts
@adaptive-tutor/src/app/api/chat/route.ts
@adaptive-tutor/src/app/api/attempts/route.ts
@adaptive-tutor/src/lib/prisma.ts
@adaptive-tutor/src/lib/schemas.ts
@adaptive-tutor/src/lib/config.ts
@adaptive-tutor/src/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate existing API routes to Prisma</name>
  <files>
    adaptive-tutor/src/app/api/study-plans/route.ts
    adaptive-tutor/src/app/api/study-plans/[id]/route.ts
    adaptive-tutor/src/app/api/study-plans/[id]/generate-graph/route.ts
    adaptive-tutor/src/app/api/chat/route.ts
    adaptive-tutor/src/app/api/attempts/route.ts
  </files>
  <action>
Migrate each API route from JSON file CRUD imports to Prisma queries. For each route file:
1. Remove `import { findMany, create, update, remove, ... } from "@/lib/db"`
2. Add `import { prisma } from "@/lib/prisma"`
3. Replace each JSON CRUD call with the equivalent Prisma call

**study-plans/route.ts (GET, POST):**
- GET: Replace `findMany<StudyPlan>("studyPlans", { userId: USER_ID })` with `prisma.studyPlan.findMany({ where: { userId: USER_ID } })`
- POST: Replace `create<StudyPlan>("studyPlans", {...})` with `prisma.studyPlan.create({ data: {...} })`
- Keep the Zod validation (CreateStudyPlanSchema) as-is
- Remove the `type StudyPlan` import if no longer needed (Prisma generates its own types)

**study-plans/[id]/route.ts (GET, PATCH, DELETE):**
- GET: Replace `findUnique<StudyPlan>("studyPlans", id)` with `prisma.studyPlan.findUnique({ where: { id } })`. Also include related concepts and edges: `include: { concepts: true, edges: true }` so the frontend gets the full study plan with graph data.
- PATCH: Replace `update<StudyPlan>("studyPlans", id, body)` with `prisma.studyPlan.update({ where: { id }, data: body })`. Add validation for allowed update fields (title, description, status, targetDate only -- do NOT allow updating userId or id).
- DELETE: Replace `remove("studyPlans", id)` and manual `removeMany` calls with `prisma.studyPlan.delete({ where: { id } })`. Prisma's cascade delete (onDelete: Cascade on ConceptNode, ConceptEdge, SessionRecord) handles cleanup automatically. Remove the manual removeMany calls.

**study-plans/[id]/generate-graph/route.ts (POST):**
- Replace `findUnique`, `create`, `removeMany` calls with Prisma equivalents
- Replace `removeMany("conceptNodes", { studyPlanId: id })` with `prisma.conceptNode.deleteMany({ where: { studyPlanId: id } })`
- Replace `removeMany("conceptEdges", { studyPlanId: id })` with `prisma.conceptEdge.deleteMany({ where: { studyPlanId: id } })`
- Replace `create<ConceptNode>(...)` with `prisma.conceptNode.create({ data: {...} })`
- Replace `create<ConceptEdge>(...)` with `prisma.conceptEdge.create({ data: {...} })`
- Consider using `prisma.$transaction([...])` to wrap the delete + create operations for atomicity
- Keep the demo graph generation logic (generateDemoGraph function) unchanged -- that's Phase 2 work
- Remove the `toJson` import from utils (use `JSON.stringify` directly or keep it)

**chat/route.ts (POST):**
- Replace `findMany<StudyPlan>` and `findMany<ConceptNode>` and `findMany<AttemptRecord>` with Prisma queries
- Use `prisma.studyPlan.findMany({ where: { userId: USER_ID, status: "active" } })` instead of filtering in JS
- Use `prisma.conceptNode.findMany({ where: { isDeprecated: false } })` for concept filtering
- Use `prisma.attemptRecord.findMany({ orderBy: { createdAt: "desc" }, take: 10 })` for recent attempts
- Keep the stub response generator (generateStubResponse) unchanged -- that's Phase 4 work

**attempts/route.ts (POST):**
- Replace `findUnique<Question>("questions", questionId)` with `prisma.question.findUnique({ where: { id: questionId } })`
- Replace `create<AttemptRecord>(...)` with `prisma.attemptRecord.create({ data: {...} })`
- Replace `update<Question>(...)` with `prisma.question.update({ where: { id: questionId }, data: { isUsed: true } })`
- Replace `findUnique<ConceptNode>(...)` and `update<ConceptNode>(...)` with Prisma calls
- IMPORTANT: Wrap the attempt creation + question update + proficiency update in a `prisma.$transaction()` for atomicity. This fixes the race condition noted in CONCERNS.md.
- Keep the evaluation logic (keyword matching, MCQ checking) unchanged -- that's Phase 3/4 work

**General rules for ALL route migrations:**
- Remove `import type { ... } from "@/lib/types"` where Prisma-generated types can be used instead. However, if the types are used elsewhere in the file for non-DB purposes, keep them.
- Keep all error handling patterns (try/catch, console.error, NextResponse.json with status codes)
- Keep all Zod validation exactly as-is
- Do NOT change any business logic -- only the persistence layer calls
- If the old db.ts wrapper functions are still imported anywhere, update those imports too
  </action>
  <verify>
Start the dev server with `npm run dev` from `adaptive-tutor/` and test each endpoint:

1. `curl http://localhost:3000/api/study-plans` -- should return `{"plans":[...]}` with the seeded demo plan
2. `curl -X POST http://localhost:3000/api/study-plans -H "Content-Type: application/json" -d '{"title":"Test Plan","sourceText":"Testing persistence"}'` -- should return 201 with created plan
3. Capture the plan ID from step 2, then: `curl http://localhost:3000/api/study-plans/{id}` -- should return the plan
4. `curl -X PATCH http://localhost:3000/api/study-plans/{id} -H "Content-Type: application/json" -d '{"title":"Updated Plan"}'` -- should return updated plan
5. `curl -X DELETE http://localhost:3000/api/study-plans/{id}` -- should return success
6. `curl http://localhost:3000/api/study-plans` -- deleted plan should not appear
7. `npx tsc --noEmit` should not have new errors in the migrated route files
  </verify>
  <done>
All existing API routes (study-plans CRUD, chat, attempts, generate-graph) use Prisma instead of JSON file CRUD. No imports from the old JSON-based db.ts pattern remain. Prisma transactions used where atomicity matters (attempts + proficiency update, graph regeneration).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ChatThread and ChatMessage CRUD endpoints</name>
  <files>
    adaptive-tutor/src/app/api/chat/threads/route.ts
    adaptive-tutor/src/app/api/chat/threads/[threadId]/messages/route.ts
  </files>
  <action>
Create new API endpoints for chat thread and message persistence. These are needed for CHAT-06 (message history persists).

**Create `src/app/api/chat/threads/route.ts`:**

```
GET /api/chat/threads — List all threads for demo user
POST /api/chat/threads — Create a new thread
```

GET handler:
- Query: `prisma.chatThread.findMany({ where: { userId: USER_ID }, orderBy: { updatedAt: "desc" }, include: { messages: { take: 1, orderBy: { createdAt: "desc" } } } })`
- Return: `{ threads: [...] }` -- each thread includes its last message for preview
- Import `USER_ID` from `@/lib/config`

POST handler:
- Accept body: `{ title?: string, studyPlanId?: string }`
- Validate with a simple Zod schema: `z.object({ title: z.string().optional().default("New Chat"), studyPlanId: z.string().nullable().optional().default(null) })`
- Create: `prisma.chatThread.create({ data: { userId: USER_ID, title, studyPlanId } })`
- Return: `{ thread: {...} }` with status 201

**Create `src/app/api/chat/threads/[threadId]/messages/route.ts`:**

```
GET /api/chat/threads/[threadId]/messages — List all messages in a thread
POST /api/chat/threads/[threadId]/messages — Add a message to a thread
```

GET handler:
- First verify the thread exists: `prisma.chatThread.findUnique({ where: { id: threadId } })`
- If not found, return 404
- Query: `prisma.chatMessage.findMany({ where: { threadId }, orderBy: { createdAt: "asc" } })`
- Return: `{ messages: [...] }`

POST handler:
- Accept body: `{ role: "user" | "assistant" | "system", content: string, toolCallsJson?: string, toolResultsJson?: string }`
- Validate with Zod schema: `z.object({ role: z.enum(["user", "assistant", "system"]), content: z.string().min(1), toolCallsJson: z.string().optional().default("[]"), toolResultsJson: z.string().optional().default("[]") })`
- Verify thread exists first (return 404 if not)
- Create message: `prisma.chatMessage.create({ data: { threadId, role, content, toolCallsJson, toolResultsJson } })`
- Also update thread's `updatedAt`: `prisma.chatThread.update({ where: { id: threadId }, data: { updatedAt: new Date() } })`
- Wrap both operations in `prisma.$transaction()` for atomicity
- Return: `{ message: {...} }` with status 201

**Follow existing codebase conventions:**
- Import pattern: NextRequest, NextResponse from "next/server", then prisma, then config, then types
- Error handling: try/catch with console.error and NextResponse.json error objects
- Use `{ params }: { params: Promise<{ threadId: string }> }` for dynamic route params (Next.js 16 pattern -- the existing routes already use Promise<> for params)
- Add Zod schemas either inline in the route files or in `src/lib/schemas.ts` (prefer schemas.ts for consistency)

**What NOT to do:**
- Do NOT modify the existing `src/app/api/chat/route.ts` -- that handles the actual chat AI response and is Phase 4 work
- Do NOT add authentication -- this is a single-user demo (USER_ID = "demo-user")
- Do NOT add pagination yet -- simple findMany is fine for hackathon scale
  </action>
  <verify>
With dev server running:

1. `curl -X POST http://localhost:3000/api/chat/threads -H "Content-Type: application/json" -d '{"title":"Test Thread"}'` -- should return 201 with thread object
2. Capture threadId, then: `curl -X POST http://localhost:3000/api/chat/threads/{threadId}/messages -H "Content-Type: application/json" -d '{"role":"user","content":"Hello world"}'` -- should return 201
3. `curl -X POST http://localhost:3000/api/chat/threads/{threadId}/messages -H "Content-Type: application/json" -d '{"role":"assistant","content":"Hi there!"}'` -- should return 201
4. `curl http://localhost:3000/api/chat/threads/{threadId}/messages` -- should return both messages in chronological order
5. `curl http://localhost:3000/api/chat/threads` -- should show the thread with last message preview
6. Stop and restart the dev server, then repeat step 4 -- messages should still be there (persistence verification for CHAT-06)
7. `curl -X POST http://localhost:3000/api/chat/threads/nonexistent-id/messages -H "Content-Type: application/json" -d '{"role":"user","content":"test"}'` -- should return 404
  </verify>
  <done>
ChatThread CRUD endpoints work (GET list, POST create). ChatMessage CRUD endpoints work (GET list by thread, POST create). Messages persist in SQLite across server restarts (CHAT-06 satisfied). Invalid thread IDs return 404. Thread updatedAt updates when new messages are added.
  </done>
</task>

</tasks>

<verification>
After both tasks are complete, run the full verification sequence:

1. **Database reset test:** Delete `prisma/dev.db`, run `npx prisma db push && npm run seed`, verify demo data exists
2. **Study plan CRUD:** Create, read, update, delete a study plan via curl
3. **Chat persistence (CHAT-06):** Create thread, add messages, restart server, verify messages persist
4. **Graph persistence (GRAPH-04):** Create study plan, generate graph (`POST /api/study-plans/{id}/generate-graph`), restart server, verify `GET /api/study-plans/{id}` returns concepts and edges
5. **Attempt recording:** If test question data exists, submit an attempt and verify proficiency updates
6. **No regressions:** `npx tsc --noEmit` passes, `npm run build` succeeds
</verification>

<success_criteria>
- All API routes use Prisma (no JSON file imports remain in any route)
- Study plan CRUD works: create, read (with concepts/edges), update, delete
- ChatThread and ChatMessage CRUD endpoints exist and work
- Message history persists across server restarts (CHAT-06)
- Concept graph data persists across server restarts (GRAPH-04)
- Attempts record to database and update proficiency atomically
- The app builds without errors (`npm run build`)
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-02-SUMMARY.md`
</output>
